Disassembly Listing for PIC32MM_mTOUCH_28
Generated From:
C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/dist/default/production/PIC32MM_mTOUCH_28.X.production.elf
Sep 12, 2014 2:26:08 PM

---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/mTouchCapLib/mTouchCapTmr.c  ---------------------------
1:                   /******************************************************************************
2:                   * File Name:       mTouchCapTmr.c
3:                   * Includes:
4:                   *   void mTouchCapTmr_IgnoreCurrentData(BOOL)
5:                   *   void mTouchCapTmr_InitTimer4(void)
6:                   *   void mTouchCapTmr_SetPeriodTimer4(unsigned int time)
7:                   *   void __attribute__((interrupt, auto_psv)) _T4Interrupt (void)
8:                   *   void __ISR(_TIMER_4_VECTOR, IPL1SOFT) mTouchCapTmr_Tmr4ISR(void)
9:                   *
10:                  * Dependencies:    None
11:                  * Processor:       PIC32MX795F512H
12:                  * Compiler:        C32
13:                  * Company:         Microchip Technology, Inc.
14:                  * Software License Agreement
15:                  *
16:                  * Copyright © 2011 Microchip Technology Inc.
17:                  * Microchip licenses this software to you solely for use with Microchip
18:                  * products, according to the terms of the accompanying click-wrap software
19:                  * license. Microchip and its licensors retain all right, title and interest in
20:                  * and to the software.  All rights reserved. This software and any accompanying
21:                  * information is for suggestion only. It shall not be deemed to modify
22:                  * Microchip?s standard warranty for its products.  It is your responsibility to
23:                  * ensure that this software meets your requirements.
24:                  *
25:                  * SOFTWARE IS PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
26:                  * IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
27:                  * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL
28:                  * MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY DIRECT OR INDIRECT DAMAGES OR
29:                  * EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
30:                  * OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
31:                  * SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, OR ANY CLAIMS BY THIRD PARTIES
32:                  * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
33:                  *
34:                  * The aggregate and cumulative liability of Microchip and its licensors for
35:                  * damages related to the use of the software will in no event exceed $1000 or
36:                  * the amount you paid Microchip for the software, whichever is greater.
37:                  *
38:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
39:                  * TERMS AND THE TERMS OF THE ACCOMPANYING CLICK-WRAP SOFTWARE LICENSE.
40:                  *
41:                  *
42:                  * Author    Date    Comments
43:                  *-------------------------------------------------------------------------
44:                  * BDB    26-Jun-2008 First release
45:                  * NK     24-Apr-2009 Porting for 18F46J50 Eval Board
46:                  * MC     22-Ian-2010 First release of TMRDriver.c, TMRDriver.h
47:                  *                    Porting for PIC32MX795F512H
48:                  * MWM    06-Sep-2011 Moved Callback to separate file.
49:                  ******************************************************************************/
50:                  #include "..\mTouchConfig.h"
51:                  #include "mTouchCapAPI.h"
52:                  #include "mTouchCapTmr.h"
53:                  
54:                  
55:                  // From  mTouchCapAPI.c
56:                  extern volatile UINT8 EmTouchDataReady;      //global indicating the reading of all channels finished
57:                  
58:                  /* timer 4 callback ISR local - init in Initialization function */
59:                  static void *T4CallBackISR;
60:                  volatile BOOL IgnoreCurrentDataFlag = FALSE; // Flag set by application to signal when mTouch
61:                                                               // should ignore data being measured.
62:                  
63:                  void TIMERCALLBACKFUNC(void); //Defined in mTouchConfig.h
64:                  
65:                  void mTouchCapTmr_IgnoreCurrentData( BOOL Flag )
66:                  {
67:                      IgnoreCurrentDataFlag = Flag;
9D001AA4  AF840008   SW A0, 8(GP)
68:                  }
9D001AA8  03E00008   JR RA
9D001AAC  00000000   NOP
69:                  
70:                  /******************************************************************************
71:                   * Function:       void InitTimer(void)
72:                   *
73:                   * PreCondition:    None
74:                   *
75:                   * Input:           unsigned int time
76:                   *
77:                   * Output:          None
78:                   *
79:                   * Side Effects:    None
80:                   *
81:                   * Overview:        Set the period for timer 4 depending on input param time
82:                   *
83:                   * Note:            Stops and restarts the timer when setting the new period
84:                   *****************************************************************************/
85:                  void mTouchCapTmr_InitTimer4(void)
86:                  {
87:                  
88:                      // set up the timer interrupt with a priority of 1
89:                      Set_ScanTimer_Priority(1);
9D001AB0  3C02BF88   LUI V0, -16504
9D001AB4  8C4410D0   LW A0, 4304(V0)
9D001AB8  24030001   ADDIU V1, ZERO, 1
9D001ABC  7C642084   INS A0, V1, 2, 3
9D001AC0  AC4410D0   SW A0, 4304(V0)
90:                      // interrupt subpriority is 0
91:                      Set_ScanTimer_Subpriority(0);
9D001AC4  8C4410D0   LW A0, 4304(V0)
9D001AC8  7C040804   INS A0, ZERO, 0, 2
9D001ACC  AC4410D0   SW A0, 4304(V0)
92:                      // clear the interrupt flag
93:                      Set_ScanTimer_IF_Bit_State(0);
9D001AD0  3C02BF88   LUI V0, -16504
9D001AD4  8C441030   LW A0, 4144(V0)
9D001AD8  7C049CC4   INS A0, ZERO, 19, 1
9D001ADC  AC441030   SW A0, 4144(V0)
94:                  
95:                      // initialize the callback pointer with the value passed as argument
96:                      T4CallBackISR = TIMERCALLBACKFUNC;
9D001AE0  3C029D00   LUI V0, -25344
9D001AE4  24423D38   ADDIU V0, V0, 15672
9D001AE8  AF82000C   SW V0, 12(GP)
97:                  
98:                      /* enable the interrupt */
99:                      Set_ScanTimer_IE_Bit_State(1);
9D001AEC  3C02BF88   LUI V0, -16504
9D001AF0  8C441060   LW A0, 4192(V0)
9D001AF4  7C649CC4   INS A0, V1, 19, 1
9D001AF8  AC441060   SW A0, 4192(V0)
100:                 
101:                     TMR4 = 0;
9D001AFC  3C02BF80   LUI V0, -16512
9D001B00  AC400C10   SW ZERO, 3088(V0)
102:                     PR4 = TIMER4_PERIOD;
9D001B04  24040BB8   ADDIU A0, ZERO, 3000
9D001B08  3C02BF80   LUI V0, -16512
9D001B0C  AC440C20   SW A0, 3104(V0)
103:                     // restart the timer
104:                     Set_ScanTimer_ON_Bit_State(1);
9D001B10  3C02BF80   LUI V0, -16512
9D001B14  8C440C00   LW A0, 3072(V0)
9D001B18  7C647BC4   INS A0, V1, 15, 1
9D001B1C  AC440C00   SW A0, 3072(V0)
105:                 
106:                     return;
107:                 }
9D001B20  03E00008   JR RA
9D001B24  00000000   NOP
108:                 
109:                 /******************************************************************************
110:                  * Function:       void SetPeriodTimer4(unsigned int time)
111:                  *
112:                  * PreCondition:    None
113:                  *
114:                  * Input:           unsigned int time
115:                  *
116:                  * Output:          None
117:                  *
118:                  * Side Effects:    None
119:                  *
120:                  * Overview:        Set the period for timer 4 depending on input param time
121:                  *
122:                  * Note:            Stops and restarts the timer when setting the new period
123:                  *****************************************************************************/
124:                 void mTouchCapTmr_SetPeriodTimer4(unsigned int time)
125:                 {
126:                     // stop the timer
127:                     Set_ScanTimer_ON_Bit_State(0);
9D001B28  3C02BF80   LUI V0, -16512
9D001B2C  8C430C00   LW V1, 3072(V0)
9D001B30  7C037BC4   INS V1, ZERO, 15, 1
9D001B34  AC430C00   SW V1, 3072(V0)
128:                     /* load the time to higher and lower byte of the timer register */
129:                     TMR4 = 0;
9D001B38  3C03BF80   LUI V1, -16512
9D001B3C  AC600C10   SW ZERO, 3088(V1)
130:                     PR4  = time;
9D001B40  3C03BF80   LUI V1, -16512
9D001B44  AC640C20   SW A0, 3104(V1)
131:                     // restart the timer
132:                     Set_ScanTimer_ON_Bit_State(1);
9D001B48  8C430C00   LW V1, 3072(V0)
9D001B4C  24040001   ADDIU A0, ZERO, 1
9D001B50  7C837BC4   INS V1, A0, 15, 1
9D001B54  AC430C00   SW V1, 3072(V0)
133:                 
134:                 }
9D001B58  03E00008   JR RA
9D001B5C  00000000   NOP
135:                 
136:                 #if defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
137:                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
138:                 void __attribute__((interrupt, auto_psv)) _T4Interrupt (void)
139:                 #else
140:                 void __ISR(_TIMER_4_VECTOR, IPL1SOFT) mTouchCapTmr_Tmr4ISR(void)
141:                 #endif
142:                 {
9D001B60  415DE800   RDPGPR SP, SP
9D001B64  401A7000   MFC0 K0, EPC
9D001B68  401B6000   MFC0 K1, Status
9D001B6C  27BDFF90   ADDIU SP, SP, -112
9D001B70  AFBA006C   SW K0, 108(SP)
9D001B74  401A6002   MFC0 K0, SRSCtl
9D001B78  AFBB0068   SW K1, 104(SP)
9D001B7C  7C1B7844   INS K1, ZERO, 1, 15
9D001B80  377B0400   ORI K1, K1, 1024
9D001B84  AFBA0064   SW K0, 100(SP)
9D001B88  409B6000   MTC0 K1, Status
9D001B8C  AFBF0054   SW RA, 84(SP)
9D001B90  AFB90050   SW T9, 80(SP)
9D001B94  AFB8004C   SW T8, 76(SP)
9D001B98  AFAF0048   SW T7, 72(SP)
9D001B9C  AFAE0044   SW T6, 68(SP)
9D001BA0  AFAD0040   SW T5, 64(SP)
9D001BA4  AFAC003C   SW T4, 60(SP)
9D001BA8  AFAB0038   SW T3, 56(SP)
9D001BAC  AFAA0034   SW T2, 52(SP)
9D001BB0  AFA90030   SW T1, 48(SP)
9D001BB4  AFA8002C   SW T0, 44(SP)
9D001BB8  AFA70028   SW A3, 40(SP)
9D001BBC  AFA60024   SW A2, 36(SP)
9D001BC0  AFA50020   SW A1, 32(SP)
9D001BC4  AFA4001C   SW A0, 28(SP)
9D001BC8  AFA30018   SW V1, 24(SP)
9D001BCC  AFA20014   SW V0, 20(SP)
9D001BD0  AFA10010   SW AT, 16(SP)
9D001BD4  00001012   MFLO V0, 0
9D001BD8  AFA2005C   SW V0, 92(SP)
9D001BE0  00001810   MFHI V1, 0
143:                     void (*ptr_fcn)(void);
144:                 
145:                     /* init local wiht the callback function ptr */
146:                     ptr_fcn = (void (*) ())T4CallBackISR;
9D001BDC  8F82000C   LW V0, 12(GP)
147:                     if (ptr_fcn != 0)
9D001BE4  10400003   BEQ V0, ZERO, 0x9D001BF4
9D001BE8  AFA30058   SW V1, 88(SP)
148:                     {
149:                         // call the callback isr
150:                         (*ptr_fcn)();
9D001BEC  0040F809   JALR V0
9D001BF0  00000000   NOP
151:                     }
152:                 
153:                     Set_ScanTimer_IF_Bit_State(DISABLE);    //Clear interrupt flag
9D001BF4  3C02BF88   LUI V0, -16504
9D001BF8  8C431030   LW V1, 4144(V0)
9D001BFC  7C039CC4   INS V1, ZERO, 19, 1
9D001C00  AC431030   SW V1, 4144(V0)
154:                     if ( EmTouchDataReady == TRUE )
9D001C04  93830010   LBU V1, 16(GP)
9D001C08  24020001   ADDIU V0, ZERO, 1
9D001C0C  306300FF   ANDI V1, V1, 255
9D001C10  14620008   BNE V1, V0, 0x9D001C34
9D001C14  3C02BF88   LUI V0, -16504
155:                     {
156:                         Set_ScanTimer_IE_Bit_State(DISABLE);    // Disable interrupt
9D001C18  8C431060   LW V1, 4192(V0)
9D001C1C  7C039CC4   INS V1, ZERO, 19, 1
9D001C20  AC431060   SW V1, 4192(V0)
157:                         Set_ScanTimer_ON_Bit_State(DISABLE);    // Stop timer 4
9D001C24  3C02BF80   LUI V0, -16512
9D001C28  8C430C00   LW V1, 3072(V0)
9D001C2C  7C037BC4   INS V1, ZERO, 15, 1
9D001C30  AC430C00   SW V1, 3072(V0)
158:                     }
159:                 
160:                 }
9D001C34  8FA2005C   LW V0, 92(SP)
9D001C38  8FA30058   LW V1, 88(SP)
9D001C3C  8FBF0054   LW RA, 84(SP)
9D001C40  00400013   MTLO V0, 0
9D001C44  8FB90050   LW T9, 80(SP)
9D001C48  8FB8004C   LW T8, 76(SP)
9D001C4C  8FAF0048   LW T7, 72(SP)
9D001C50  00600011   MTHI V1, 0
9D001C54  8FAE0044   LW T6, 68(SP)
9D001C58  8FAD0040   LW T5, 64(SP)
9D001C5C  8FAC003C   LW T4, 60(SP)
9D001C60  8FAB0038   LW T3, 56(SP)
9D001C64  8FAA0034   LW T2, 52(SP)
9D001C68  8FA90030   LW T1, 48(SP)
9D001C6C  8FA8002C   LW T0, 44(SP)
9D001C70  8FA70028   LW A3, 40(SP)
9D001C74  8FA60024   LW A2, 36(SP)
9D001C78  8FA50020   LW A1, 32(SP)
9D001C7C  8FA4001C   LW A0, 28(SP)
9D001C80  8FA30018   LW V1, 24(SP)
9D001C84  8FA20014   LW V0, 20(SP)
9D001C88  8FA10010   LW AT, 16(SP)
9D001C8C  41606000   DI ZERO
9D001C90  000000C0   EHB
9D001C94  8FBA006C   LW K0, 108(SP)
9D001C98  8FBB0068   LW K1, 104(SP)
9D001C9C  409A7000   MTC0 K0, EPC
9D001CA0  8FBA0064   LW K0, 100(SP)
9D001CA4  27BD0070   ADDIU SP, SP, 112
9D001CA8  409A6002   MTC0 K0, SRSCtl
9D001CAC  41DDE800   WRPGPR SP, SP
9D001CB0  409B6000   MTC0 K1, Status
9D001CB4  42000018   ERET
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/mTouchCapLib/mTouchCapStatus.c  ------------------------
1:                   /*****************************************************************************
2:                   * FileName:         mTouchCapStatus.c
3:                   *
4:                   * Includes:
5:                   *   void mTouchCapStatus_Reset(UINT16 SliderValue)
6:                   *   void mTouchCapStatus_Capture(void)
7:                   *   void mTouchCapStatus_Restore(void)
8:                   *   void mTouchCapStatus_SetEmTouchDataReady( UINT8 FlagValue )
9:                   *   UINT16 mTouchCapStatus_Check(UINT16 *pCurrentButtonStatus,
10:                  *                            UINT16 *pCurrentButtonAsserts,
11:                  *                            UINT16 *pSliderValue)
12:                  *
13:                  * Dependencies:     ??
14:                  * Processor:        PIC32
15:                  * Compiler:         C32
16:                  * Linker:           MPLAB LINK32
17:                  * Company:          Microchip Technology Incorporated
18:                  *
19:                  * Software License Agreement
20:                  *
21:                  * Copyright © 2011 Microchip Technology Inc.
22:                  * Microchip licenses this software to you solely for use with Microchip
23:                  * products, according to the terms of the accompanying click-wrap software
24:                  * license. Microchip and its licensors retain all right, title and interest in
25:                  * and to the software.  All rights reserved. This software and any accompanying
26:                  * information is for suggestion only. It shall not be deemed to modify
27:                  * Microchip?s standard warranty for its products.  It is your responsibility to
28:                  * ensure that this software meets your requirements.
29:                  *
30:                  * SOFTWARE IS PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
31:                  * IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
32:                  * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL
33:                  * MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY DIRECT OR INDIRECT DAMAGES OR
34:                  * EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
35:                  * OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
36:                  * SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, OR ANY CLAIMS BY THIRD PARTIES
37:                  * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
38:                  *
39:                  * The aggregate and cumulative liability of Microchip and its licensors for
40:                  * damages related to the use of the software will in no event exceed $1000 or
41:                  * the amount you paid Microchip for the software, whichever is greater.
42:                  *
43:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                  * TERMS AND THE TERMS OF THE ACCOMPANYING CLICK-WRAP SOFTWARE LICENSE.
45:                  *
46:                  *
47:                  * Author       Date        Comment
48:                  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
49:                  * MWM          21 Jul 2011  Moved from main file to this file for simplicity
50:                  *******************************************************************************/
51:                  
52:                  #include "GenericTypeDefs.h"
53:                  #include "mTouchCapStatus.h"
54:                  #include "..\HardwareProfile.h"
55:                  #include "mTouchCapAPI.h"
56:                  #include "mTouchCapPhy.h"
57:                  #if defined( DUMP_DIAGNOSTICS_VIA_UART )
58:                  #include  <stdio.h>
59:                  #endif
60:                  #include "mTouchCapApp_DirectKeys.h"
61:                  
62:                  /** External Variables **/
63:                  // From mTouchCapAPI.c
64:                  extern volatile UINT8 EmTouchDataReady;
65:                  extern UINT8  HF_Read_Number;
66:                  extern UINT8  NumberScanChannels;
67:                  extern UINT16 ScanChannels[MAX_ADC_CHANNELS];
68:                  extern UINT16 averageData[MAX_ADC_CHANNELS];   // running average of CVD channels
69:                  
70:                  // from mTouchCapPhy.c
71:                  extern UINT16 CurFiltdData[MAX_ADC_CHANNELS]; // current filtered value for all channels
72:                  
73:                  // Status static storage
74:                  static UINT16 LastButtonStatus = 0;
75:                  static  INT16 LastSliderValue  = 0;
76:                  static UINT16 AvgDataCapture[MAX_ADC_CHANNELS];
77:                  
78:                  // From mTouchCapPhy.c
79:                  #if defined( DUMP_DIAGNOSTICS_VIA_UART )
80:                  void SendDataBuffer(const char *buffer, UINT32 size);
81:                  
82:                  #if   defined( UART_DUMP_RAW_COUNTS )
83:                  UINT16 CurRawData[  NUM_HF_READS][MAX_ADC_CHANNELS]; // Scratch storage for UART dump
84:                  #elif defined( UART_DUMP_ALL_COUNTS )
85:                  UINT16 CurRawData[3*NUM_HF_READS][MAX_ADC_CHANNELS]; // Scratch storage for UART dump
86:                  #endif
87:                  
88:                  #endif//defined( DUMP_DIAGNOSTICS_VIA_UART )
89:                  
90:                  
91:                  void mTouchCapStatus_Reset(UINT16 SliderValue)
92:                  {
93:                      LastButtonStatus = 0;
9D00180C  A7800004   SH ZERO, 4(GP)
94:                      LastSliderValue  = SliderValue;
95:                  }
9D001810  03E00008   JR RA
9D001814  A7840006   SH A0, 6(GP)
96:                  
97:                  void mTouchCapStatus_Capture(void)
98:                  {
99:                      UINT16 iScanChan, iButton;
100:                     for(iButton=0; iButton<NumberScanChannels; iButton++)
9D001818  3C03A000   LUI V1, -24576
9D001824  93870001   LBU A3, 1(GP)
9D001828  24630144   ADDIU V1, V1, 324
9D00182C  00001021   ADDU V0, ZERO, ZERO
9D001834  0B400617   J 0x9D00185C
9D001838  24A50058   ADDIU A1, A1, 88
9D00183C  24420001   ADDIU V0, V0, 1
9D001840  3042FFFF   ANDI V0, V0, -1
9D001854  24630002   ADDIU V1, V1, 2
9D00185C  0047202B   SLTU A0, V0, A3
9D001860  5480FFF6   BNEL A0, ZERO, 0x9D00183C
9D001864  94640000   LHU A0, 0(V1)
101:                     {
102:                         iScanChan = ScanChannels[iButton];
103:                         AvgDataCapture[iScanChan] = averageData[iScanChan];
9D00181C  3C06A000   LUI A2, -24576
9D001820  3C05A000   LUI A1, -24576
9D001830  24C60160   ADDIU A2, A2, 352
9D001844  00042040   SLL A0, A0, 1
9D001848  00864021   ADDU T0, A0, A2
9D00184C  00852021   ADDU A0, A0, A1
9D001850  94840000   LHU A0, 0(A0)
9D001858  A5040000   SH A0, 0(T0)
104:                     }
105:                 }
9D001868  03E00008   JR RA
9D00186C  00000000   NOP
106:                 
107:                 void mTouchCapStatus_Restore(void)
108:                 {
9D001870  27BDFFD8   ADDIU SP, SP, -40
9D001874  AFB40020   SW S4, 32(SP)
9D001878  AFB3001C   SW S3, 28(SP)
9D00187C  AFB20018   SW S2, 24(SP)
9D001880  AFB10014   SW S1, 20(SP)
9D001894  AFB00010   SW S0, 16(SP)
9D001898  AFBF0024   SW RA, 36(SP)
109:                     UINT16 iScanChan, iButton;
110:                     for(iButton=0; iButton<NumberScanChannels; iButton++)
9D00189C  00008021   ADDU S0, ZERO, ZERO
9D0018AC  0B400639   J 0x9D0018E4
9D0018B0  26310090   ADDIU S1, S1, 144
9D0018BC  26100001   ADDIU S0, S0, 1
9D0018C0  3210FFFF   ANDI S0, S0, -1
9D0018E4  93820001   LBU V0, 1(GP)
9D0018E8  0202102B   SLTU V0, S0, V0
9D0018EC  5440FFF1   BNEL V0, ZERO, 0x9D0018B4
9D0018F0  00101040   SLL V0, S0, 1
111:                     {
112:                         iScanChan = ScanChannels[iButton];
9D001884  3C14A000   LUI S4, -24576
9D0018A0  26940144   ADDIU S4, S4, 324
9D0018B4  00541021   ADDU V0, V0, S4
113:                         averageData[iScanChan]  = AvgDataCapture[iScanChan];
9D001888  3C13A000   LUI S3, -24576
9D00188C  3C12A000   LUI S2, -24576
9D0018A4  26730160   ADDIU S3, S3, 352
9D0018A8  26520058   ADDIU S2, S2, 88
9D0018B8  94440000   LHU A0, 0(V0)
9D0018C4  00041040   SLL V0, A0, 1
9D0018C8  00531821   ADDU V1, V0, S3
9D0018CC  94630000   LHU V1, 0(V1)
9D0018D0  00522821   ADDU A1, V0, S2
9D0018D8  A4A30000   SH V1, 0(A1)
114:                         CurFiltdData[iScanChan] = AvgDataCapture[iScanChan];
9D001890  3C11A000   LUI S1, -24576
9D0018D4  00511021   ADDU V0, V0, S1
115:                         mTouchCapPhy_TripValCalc(iScanChan);
9D0018DC  0F400404   JAL mTouchCapPhy_TripValCalc
9D0018E0  A4430000   SH V1, 0(V0)
116:                     }
117:                 }
9D0018F4  8FBF0024   LW RA, 36(SP)
9D0018F8  8FB40020   LW S4, 32(SP)
9D0018FC  8FB3001C   LW S3, 28(SP)
9D001900  8FB20018   LW S2, 24(SP)
9D001904  8FB10014   LW S1, 20(SP)
9D001908  8FB00010   LW S0, 16(SP)
9D00190C  03E00008   JR RA
9D001910  27BD0028   ADDIU SP, SP, 40
118:                 
119:                 void mTouchCapStatus_SetEmTouchDataReady( UINT8 FlagValue )
120:                 {
9D001914  308400FF   ANDI A0, A0, 255
121:                     EmTouchDataReady = FlagValue;
9D001918  A3840010   SB A0, 16(GP)
122:                 }
9D00191C  03E00008   JR RA
9D001920  00000000   NOP
123:                 
124:                 UINT16 mTouchCapStatus_Check(UINT16 *pCurrentButtonStatus,
125:                                              UINT16 *pCurrentButtonAsserts,
126:                                              UINT16 *pSliderValue)
127:                 {
9D001924  27BDFF78   ADDIU SP, SP, -136
9D001928  AFB00074   SW S0, 116(SP)
9D00192C  00808021   ADDU S0, A0, ZERO
9D001938  AFB30080   SW S3, 128(SP)
9D001940  AFB2007C   SW S2, 124(SP)
9D001944  AFB10078   SW S1, 120(SP)
9D001948  AFBF0084   SW RA, 132(SP)
9D00194C  00A09821   ADDU S3, A1, ZERO
9D001950  00C09021   ADDU S2, A2, ZERO
128:                 #if defined( DUMP_DIAGNOSTICS_VIA_UART )
129:                     char   ButtonMeasString[133];
130:                 #  if defined ( UART_DUMP_RAW_COUNTS )
131:                     UINT16 iHF_Read;
132:                 #  endif
133:                 #endif
134:                     UINT16 iButton,
135:                            WeightSum,
136:                            RawSliderValue = 0,
137:                            WeightDeviation,
138:                            FullScalePerButton = 256/NumberScanChannels; //256 counts = 100%
9D001954  93910001   LBU S1, 1(GP)
9D0019FC  24040100   ADDIU A0, ZERO, 256
9D001A14  0091001A   DIV A0, S1
9D001A18  022001F4   TEQ S1, ZERO
9D001A1C  00008812   MFLO S1, 0
139:                     INT16  CorrectedSliderValue = 0, SliderValue;
140:                     UINT16 CurrentButtonMeasurements[MAX_ADC_CHANNELS],
141:                            CurrentAveragedMeasurements[MAX_ADC_CHANNELS],
142:                            CurrentWeights[MAX_ADC_CHANNELS];
143:                 
144:                     if(EmTouchDataReady == 1)  //This flag is set by Timer ISR when all channels have been read
9D001930  93840010   LBU A0, 16(GP)
9D001934  24030001   ADDIU V1, ZERO, 1
9D00193C  308400FF   ANDI A0, A0, 255
9D001958  1483004B   BNE A0, V1, 0x9D001A88
9D00195C  00001021   ADDU V0, ZERO, ZERO
145:                     {
146:                         //  Calculate new button values and return the measurement updates
147:                         mTouchCapPhy_UpdateData(CurrentButtonMeasurements,
9D001960  27A40018   ADDIU A0, SP, 24
9D001964  27A50034   ADDIU A1, SP, 52
9D001968  27A60050   ADDIU A2, SP, 80
9D00196C  24070001   ADDIU A3, ZERO, 1
9D001970  0F40041C   JAL mTouchCapPhy_UpdateData
9D001974  AFA00010   SW ZERO, 16(SP)
148:                                                 CurrentAveragedMeasurements,
149:                                                 CurrentWeights,
150:                                                 TRUE, FILTER_METHOD_USECHANNEL);
151:                 
152:                         // Update button and LED status and return button status for use with mTouch GUI on PC
153:                         *pCurrentButtonStatus = mTouchCapApp_DirectKeys_Demo();
9D001978  0F4007A7   JAL mTouchCapApp_DirectKeys_Demo
9D00197C  00000000   NOP
154:                 
155:                         // Check for button asserts: If buttons were pressed before, but none pressed now
156:                         if ( *pCurrentButtonStatus == 0 && LastButtonStatus > 0 )
9D001980  14400004   BNE V0, ZERO, 0x9D001994
9D001984  A6020000   SH V0, 0(S0)
9D001988  97820004   LHU V0, 4(GP)
9D00198C  54400001   BNEL V0, ZERO, 0x9D001994
9D001990  A6620000   SH V0, 0(S3)
157:                         {
158:                             *pCurrentButtonAsserts = LastButtonStatus; //Buttons have fired.
159:                         }
160:                         else
161:                         { //No buttons asserted
162:                            //*pCurrentButtonAsserts = 0;
163:                         }
164:                 
165:                         if ( *pCurrentButtonStatus > 0 ) // Something is happening on the buttons
9D001994  96030000   LHU V1, 0(S0)
9D001998  10600030   BEQ V1, ZERO, 0x9D001A5C
9D00199C  00001021   ADDU V0, ZERO, ZERO
166:                         {
167:                             // Calculate slider value for buttons as weighted average of weight deviation from max
168:                             WeightSum = 0;
169:                             RawSliderValue = 0;
170:                             for ( iButton = 0; iButton < NumberScanChannels ; iButton++ )
9D0019A0  93820001   LBU V0, 1(GP)
9D0019A4  27A60050   ADDIU A2, SP, 80
9D0019A8  00002821   ADDU A1, ZERO, ZERO
9D0019AC  00001821   ADDU V1, ZERO, ZERO
9D0019B0  00002021   ADDU A0, ZERO, ZERO
9D0019E4  0082382B   SLTU A3, A0, V0
9D0019E8  54E0FFF4   BNEL A3, ZERO, 0x9D0019BC
9D0019EC  94C70000   LHU A3, 0(A2)
171:                             {
172:                                 WeightDeviation = 256 - CurrentWeights[iButton];
9D0019B4  0B400679   J 0x9D0019E4
9D0019B8  24080100   ADDIU T0, ZERO, 256
9D0019C4  01073823   SUBU A3, T0, A3
9D0019C8  30E7FFFF   ANDI A3, A3, -1
173:                                 WeightSum   += WeightDeviation;
9D0019BC  24840001   ADDIU A0, A0, 1
9D0019C0  3084FFFF   ANDI A0, A0, -1
9D0019D0  00671821   ADDU V1, V1, A3
9D0019D4  3063FFFF   ANDI V1, V1, -1
174:                                 RawSliderValue += WeightDeviation*(iButton+1); // Buttons in natural order
9D0019CC  70874802   MUL T1, A0, A3
9D0019D8  24C60002   ADDIU A2, A2, 2
9D0019DC  01252821   ADDU A1, T1, A1
9D0019E0  30A5FFFF   ANDI A1, A1, -1
175:                               //RawSliderValue += WeightDeviation*(NumberScanChannels-iButton); // Buttons in reversed order
176:                             }
177:                             // Average Weight when 256 counts is full scale (100%)
178:                             RawSliderValue = ((256*RawSliderValue)/NumberScanChannels)/WeightSum;
9D0019F0  00052A00   SLL A1, A1, 8
9D0019F4  00A2001A   DIV A1, V0
9D0019F8  004001F4   TEQ V0, ZERO
9D001A00  00002812   MFLO A1, 0
9D001A04  00A3001A   DIV A1, V1
9D001A08  006001F4   TEQ V1, ZERO
9D001A0C  00001812   MFLO V1, 0
179:                             // Correct for 1st button, 256 counts = 100%
180:                             CorrectedSliderValue = (NumberScanChannels*((INT16)RawSliderValue-FullScalePerButton))/(NumberScanChannels-1);
9D001A10  7C031E20   SEH V1, V1
9D001A20  00718823   SUBU S1, V1, S1
9D001A24  72228802   MUL S1, S1, V0
9D001A28  2442FFFF   ADDIU V0, V0, -1
9D001A2C  0222001A   DIV S1, V0
9D001A30  004001F4   TEQ V0, ZERO
9D001A34  00001012   MFLO V0, 0
181:                             CorrectedSliderValue = (CorrectedSliderValue <  0 ) ?   0 : CorrectedSliderValue;
9D001A38  7C021E20   SEH V1, V0
9D001A3C  00031827   NOR V1, ZERO, V1
9D001A40  00031FC3   SRA V1, V1, 31
182:                             CorrectedSliderValue = (CorrectedSliderValue > 256) ? 256 : CorrectedSliderValue;
9D001A44  00431024   AND V0, V0, V1
9D001A48  7C021E20   SEH V1, V0
9D001A4C  28630101   SLTI V1, V1, 257
9D001A50  50600001   BEQL V1, ZERO, 0x9D001A58
9D001A54  24020100   ADDIU V0, ZERO, 256
9D001A58  7C021620   SEH V0, V0
183:                         }
184:                         else // Nothing is happening, put slider to sleep
185:                         {
186:                             //RawSliderValue = 0;
187:                             SliderValue = LastSliderValue;
188:                         }
189:                         SliderValue = ( CorrectedSliderValue + ((1<<2) - 1)*LastSliderValue )>>2;
9D001A5C  87840006   LH A0, 6(GP)
9D001A60  24030003   ADDIU V1, ZERO, 3
9D001A64  70832802   MUL A1, A0, V1
9D001A68  00A21021   ADDU V0, A1, V0
9D001A6C  00021083   SRA V0, V0, 2
9D001A70  7C021620   SEH V0, V0
190:                         LastSliderValue  = SliderValue;
9D001A74  A7820006   SH V0, 6(GP)
191:                         *pSliderValue    = (UINT16)SliderValue;
9D001A78  A6420000   SH V0, 0(S2)
192:                 
193:                 #      if defined( UART_DUMP_RAW_COUNTS )
194:                         for ( iHF_Read = 0; iHF_Read <   NUM_HF_READS; iHF_Read++ )
195:                 #      elif defined( UART_DUMP_ALL_COUNTS )
196:                         for ( iHF_Read = 0; iHF_Read < 3*NUM_HF_READS; iHF_Read++ )
197:                 #      endif
198:                 #      if defined( UART_DUMP_RAW_COUNTS ) || defined( UART_DUMP_ALL_COUNTS )
199:                         {
200:                             sprintf(ButtonMeasString,
201:                                     "%05d,%05d,%05d,%05d,"
202:                                     "%05d,%05d,%05d,%05d,"
203:                                     "\r\n",
204:                                     iHF_Read+1,*pCurrentButtonStatus,*pCurrentButtonAsserts,RawSliderValue,
205:                                     CurRawData[iHF_Read][0],CurRawData[iHF_Read][1],CurRawData[iHF_Read][2],CurRawData[iHF_Read][3]);
206:                             SendDataBuffer(ButtonMeasString, strlen(ButtonMeasString) );
207:                         }
208:                 #      endif
209:                 
210:                 #      if defined( DUMP_DIAGNOSTICS_VIA_UART )
211:                         sprintf( ButtonMeasString,
212:                                  "%05d,%05d,%05d,."
213:                                  "%05d,%05d,%05d,%05d,"
214:                                  "%05d,%05d,%05d,%05d,"
215:                                  "%05d,%05d,%05d"
216:                                  "\r\n",
217:                                  *pCurrentButtonStatus, *pCurrentButtonAsserts, RawSliderValue,
218:                                  CurrentButtonMeasurements[0], CurrentAveragedMeasurements[0],
219:                                  CurrentButtonMeasurements[1], CurrentAveragedMeasurements[1],
220:                                  CurrentButtonMeasurements[2], CurrentAveragedMeasurements[2],
221:                                  CurrentButtonMeasurements[3], CurrentAveragedMeasurements[3],
222:                                  RawSliderValue, CorrectedSliderValue, SliderValue );
223:                         SendDataBuffer(ButtonMeasString, strlen(ButtonMeasString) );
224:                 #      endif//defined( DUMP_DIAGNOSTICS_VIA_UART )
225:                 
226:                 
227:                         LastButtonStatus = *pCurrentButtonStatus; //Remember button status
9D001A7C  96020000   LHU V0, 0(S0)
9D001A80  A7820004   SH V0, 4(GP)
228:                 
229:                         return 1; // Something happened
9D001A84  24020001   ADDIU V0, ZERO, 1
230:                     }
231:                     else
232:                     {
233:                         return 0; // Nothing happened
234:                     } // end if(EmTouchDataReady)
235:                 
236:                 }
9D001A88  8FBF0084   LW RA, 132(SP)
9D001A8C  8FB30080   LW S3, 128(SP)
9D001A90  8FB2007C   LW S2, 124(SP)
9D001A94  8FB10078   LW S1, 120(SP)
9D001A98  8FB00074   LW S0, 116(SP)
9D001A9C  03E00008   JR RA
9D001AA0  27BD0088   ADDIU SP, SP, 136
237:                 
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/mTouchCapLib/mTouchCapPhy.c  ---------------------------
1:                   /*****************************************************************************
2:                   * FileName:        mTouchCapPhy.c
3:                   * Includes:
4:                   *   void mTouchCapPhy_UpdateData( UINT16 *CurrentMeasurementData,
5:                   *                                 UINT16 *AveragedData,
6:                   *                                 UINT16 *Weights,
7:                   *                                 BOOL    UpdateAverages,
8:                   *                                 UINT16  AvgFilterType )
9:                   *   void mTouchCapPhy_StablizeChannelData(void)
10:                  *   void mTouchCapPhy_TripValCalc(WORD Index)
11:                  *   void mTouchCapPhy_AdcSetup(void)
12:                  *   void mTouchCapPhy_TickInit(void)
13:                  *   void mTouchCapPhy_Initialize(void)
14:                  *
15:                  * Software License Agreement
16:                  *
17:                  * Copyright © 2011 Microchip Technology Inc.
18:                  * Microchip licenses this software to you solely for use with Microchip
19:                  * products, according to the terms of the accompanying click-wrap software
20:                  * license. Microchip and its licensors retain all right, title and interest in
21:                  * and to the software.  All rights reserved. This software and any accompanying
22:                  * information is for suggestion only. It shall not be deemed to modify
23:                  * Microchip?s standard warranty for its products.  It is your responsibility to
24:                  * ensure that this software meets your requirements.
25:                  *
26:                  * SOFTWARE IS PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
27:                  * IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
28:                  * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL
29:                  * MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY DIRECT OR INDIRECT DAMAGES OR
30:                  * EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
31:                  * OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
32:                  * SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, OR ANY CLAIMS BY THIRD PARTIES
33:                  * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
34:                  *
35:                  * The aggregate and cumulative liability of Microchip and its licensors for
36:                  * damages related to the use of the software will in no event exceed $1000 or
37:                  * the amount you paid Microchip for the software, whichever is greater.
38:                  *
39:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
40:                  * TERMS AND THE TERMS OF THE ACCOMPANYING CLICK-WRAP SOFTWARE LICENSE.
41:                  *
42:                  * Author                Date         Comment
43:                  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
44:                  * Naveen. M             14 Apr 2009  Version 0.1 Initial Draft
45:                  * Nithin Kumar. M       14 May 2009  Version 0.2 Updates
46:                  * Sasha. M / Naveen. M  4 June 2009  Version 0.3 Updates
47:                  * Sasha. M / Naveen. M  11 Nov 2009  Version 1.0 Release
48:                  * Sasha. M / Nithin.    10 Apr 2010  Version 1.20 Release
49:                  * MC                    10 Aug 2010  Version 1.21 Release
50:                  * MWM                   28 Mar 2011  Added mTouchCapPhy_UpdateData
51:                  *****************************************************************************/
52:                  
53:                  
54:                  ////////////////////////////////////////////////////////////////////////////////
55:                  //  Includes
56:                  ////////////////////////////////////////////////////////////////////////////////
57:                  #include "..\mTouchConfig.h"
58:                  #include "mTouchCapAPI.h"
59:                  #include "mTouchCapTmr.h"
60:                  #include "mTouchCapPhy.h"
61:                  
62:                  
63:                  /* if sampling delay is 0, make sure that the conversion starts simultaneous */
64:                  #if (SAMPLING_DELAY == 0)
65:                  #   define BEGIN_CONVERSION_IMMEDIATELY
66:                  #else
67:                  #   define SAMPLING_DELAY_REF         SAMPLING_DELAY
68:                  #   undef BEGIN_CONVERSION_IMMEDIATELY
69:                  #endif//(SAMPLING_DELAY == 0)
70:                  
71:                  // From  mTouchCapAPI.c
72:                  extern  UINT8 HF_Read_Number;    //HF repeat number in current scan
73:                  extern  UINT8 NumberScanChannels;
74:                  extern UINT16 ScanChannels[MAX_ADC_CHANNELS];
75:                  
76:                  extern UINT16 averageData[MAX_ADC_CHANNELS];   // running average of CVD channels
77:                  extern volatile UINT8 EmTouchDataReady;//global indicating the reading of all channels finished
78:                  extern UINT8 button_set_number; //button current scan
79:                  extern UINT16 hystValue  [MAX_ADC_CHANNELS];
80:                  extern UINT16 tripValue  [MAX_ADC_CHANNELS];
81:                  
82:                  
83:                  /* Global Variables referenced elsewhere *************************************/
84:                  UINT8  chFilterType[MAX_ADC_CHANNELS]; // Channel filter type
85:                  UINT16 CurFiltdData[MAX_ADC_CHANNELS]; // current filtered value for all channels
86:                  UINT16 ButtonWeight[MAX_ADC_CHANNELS]; // measurement of button presses
87:                  UINT16 MinButtonWeight;
88:                  INT8   iScanChanMinWeight;
89:                  
90:                  #if   defined( UART_DUMP_RAW_COUNTS )
91:                  volatile UINT16 CurRawData[  NUM_HF_READS][MAX_ADC_CHANNELS]; // Scratch storage for UART dump
92:                  #elif defined( UART_DUMP_ALL_COUNTS )
93:                  volatile UINT16 CurRawData[3*NUM_HF_READS][MAX_ADC_CHANNELS]; // Scratch storage for UART dump
94:                  #endif
95:                  
96:                  // Cumulative sum for average measurement calculation
97:                  // used to compute "current raw value" afer NUM_HF_READs
98:                  volatile UINT32 ButtonCumulativeSum[MAX_ADC_CHANNELS];
99:                  
100:                 void mTouchCapPhy_UpdateData( UINT16 *CurrentMeasurementData,
101:                                               UINT16 *AveragedData,
102:                                               UINT16 *Weights,
103:                                               BOOL    UpdateAverages,
104:                                               UINT16  AvgFilterType )
105:                 {
9D001070  27BDFFB8   ADDIU SP, SP, -72
9D001078  AFB7003C   SW S7, 60(SP)
9D00107C  AFB60038   SW S6, 56(SP)
9D001080  AFB3002C   SW S3, 44(SP)
9D001098  AFBE0040   SW S8, 64(SP)
9D00109C  AFB50034   SW S5, 52(SP)
9D0010A0  AFB40030   SW S4, 48(SP)
9D0010A4  AFB20028   SW S2, 40(SP)
9D0010A8  AFB00020   SW S0, 32(SP)
9D0010AC  00C0F021   ADDU S8, A2, ZERO
9D0010B0  AFBF0044   SW RA, 68(SP)
9D0010B4  AFB10024   SW S1, 36(SP)
9D0010B8  AFA40048   SW A0, 72(SP)
9D0010BC  AFA5004C   SW A1, 76(SP)
9D0010C0  00E0A821   ADDU S5, A3, ZERO
9D0010C4  97B20058   LHU S2, 88(SP)
106:                     UINT16 ButtonWeightTemp;
107:                     UINT16 ButtonRawData;
108:                     UINT8  iScanChan;
109:                     UINT8  iButton; //Which button
110:                     BYTE   FilterType;
111:                 
112:                     iScanChanMinWeight = -1; //Assume no buttons are being pressed
9D001074  2402FFFF   ADDIU V0, ZERO, -1
9D001084  A3820036   SB V0, 54(GP)
113:                     MinButtonWeight = 1<<8;;
9D00108C  24020100   ADDIU V0, ZERO, 256
9D0010C8  A7820034   SH V0, 52(GP)
114:                     // Compute average of all HF scans, update averages
115:                     for(iButton=0; iButton<NumberScanChannels; iButton++)
9D0010CC  00003021   ADDU A2, ZERO, ZERO
9D0010DC  0B4004C1   J 0x9D001304
9D0010E0  26740090   ADDIU S4, S3, 144
9D0012F8  24C60001   ADDIU A2, A2, 1
9D001300  30C600FF   ANDI A2, A2, 255
9D001304  93820001   LBU V0, 1(GP)
9D001308  00C2102B   SLTU V0, A2, V0
9D00130C  1440FF75   BNE V0, ZERO, 0x9D0010E4
9D001310  00061880   SLL V1, A2, 2
116:                     {
117:                         CurrentMeasurementData[iButton] = ButtonCumulativeSum[iButton]/NUM_HF_READS;
9D001088  3C16A000   LUI S6, -24576
9D0010D0  26D600BC   ADDIU S6, S6, 188
9D0010E4  00761821   ADDU V1, V1, S6
9D0010E8  8C620000   LW V0, 0(V1)
9D0010EC  8FA50048   LW A1, 72(SP)
9D0010F0  00068840   SLL S1, A2, 1
9D0010F4  7C427940   EXT V0, V0, 5, 16
9D0010F8  00B12021   ADDU A0, A1, S1
9D0010FC  A4820000   SH V0, 0(A0)
118:                         ButtonCumulativeSum[iButton] = 0;
9D001100  AC600000   SW ZERO, 0(V1)
119:                 
120:                         iScanChan = ScanChannels[iButton];
9D001090  3C17A000   LUI S7, -24576
9D0010D4  26F70144   ADDIU S7, S7, 324
9D0010D8  3C10A000   LUI S0, -24576
9D001104  02371821   ADDU V1, S1, S7
9D001108  90630000   LBU V1, 0(V1)
121:                         CurFiltdData[iScanChan] = CurrentMeasurementData[iButton];
9D001094  3C13A000   LUI S3, -24576
9D00110C  26640090   ADDIU A0, S3, 144
9D001110  00032840   SLL A1, V1, 1
9D001114  00A42021   ADDU A0, A1, A0
9D001118  A4820000   SH V0, 0(A0)
122:                 
123:                         if ( UpdateAverages == TRUE )
9D00111C  24040001   ADDIU A0, ZERO, 1
9D001120  56A4004B   BNEL S5, A0, 0x9D001250
9D001124  8FA2004C   LW V0, 76(SP)
124:                         {
125:                             if ( AvgFilterType == FILTER_METHOD_USECHANNEL )
9D001128  16400005   BNE S2, ZERO, 0x9D001140
9D00112C  324400FF   ANDI A0, S2, 255
126:                             {
127:                                 FilterType = chFilterType[iScanChan];
9D001130  3C04A000   LUI A0, -24576
9D001134  248400AC   ADDIU A0, A0, 172
9D001138  00642021   ADDU A0, V1, A0
9D00113C  90840000   LBU A0, 0(A0)
128:                             }
129:                             else
130:                             {
131:                                 FilterType = AvgFilterType;
132:                             }
133:                 
134:                             switch(FilterType)
9D001140  24050002   ADDIU A1, ZERO, 2
9D001144  10850013   BEQ A0, A1, 0x9D001194
9D001148  2C850003   SLTIU A1, A0, 3
9D00114C  10A00006   BEQ A1, ZERO, 0x9D001168
9D001150  00033840   SLL A3, V1, 1
9D001154  24050001   ADDIU A1, ZERO, 1
9D001158  5485003D   BNEL A0, A1, 0x9D001250
9D00115C  8FA2004C   LW V0, 76(SP)
9D001168  24050003   ADDIU A1, ZERO, 3
9D00116C  50850012   BEQL A0, A1, 0x9D0011B8
9D001170  26040058   ADDIU A0, S0, 88
9D001174  24020004   ADDIU V0, ZERO, 4
9D001178  14820035   BNE A0, V0, 0x9D001250
9D00117C  8FA2004C   LW V0, 76(SP)
135:                             {
136:                                 case FILTER_METHOD_DONTAVERAGE:
137:                                     averageData[iScanChan] = CurFiltdData[iScanChan];
9D001160  0B400462   J 0x9D001188
9D001164  26040058   ADDIU A0, S0, 88
9D001188  00873821   ADDU A3, A0, A3
138:                                   //mTouchCapPhy_TripValCalc(iScanChan); // No use doing this.  Need more data to update trip and hysteresis values.
139:                 
140:                                     break;
9D00118C  0B400493   J 0x9D00124C
9D001190  A4E20000   SH V0, 0(A3)
141:                 
142:                                 case FILTER_METHOD_FASTAVERAGE:
143:                                     if (CurFiltdData[iScanChan]  > averageData[iScanChan])
9D001194  00032840   SLL A1, V1, 1
9D001198  26040058   ADDIU A0, S0, 88
9D00119C  00A42021   ADDU A0, A1, A0
9D0011A0  94850000   LHU A1, 0(A0)
9D0011A4  00A2282B   SLTU A1, A1, V0
9D0011A8  54A0000A   BNEL A1, ZERO, 0x9D0011D4
9D0011AC  A4820000   SH V0, 0(A0)
144:                                     {
145:                                         averageData[iScanChan] = CurFiltdData[iScanChan]; // If CurFiltdData is above Average, reset to high average.
146:                                     }
147:                                     mTouchCapPhy_TripValCalc(iScanChan);
148:                 
149:                                     break;
150:                 
151:                                 case FILTER_METHOD_SLOWAVERAGE:
152:                                     // Average in raw value.
153:                                     averageData[iScanChan] =
9D0011C0  00021142   SRL V0, V0, 5
9D0011C4  00821021   ADDU V0, A0, V0
9D0011C8  00042142   SRL A0, A0, 5
9D0011CC  00442023   SUBU A0, V0, A0
9D0011D0  A4E40000   SH A0, 0(A3)
154:                                         ( averageData[iScanChan] - (averageData[iScanChan]>>LOG2_ALPHA_INVERSE) )
9D0011B8  00873821   ADDU A3, A0, A3
9D0011BC  94E40000   LHU A0, 0(A3)
155:                                         + (CurFiltdData[iScanChan]>>LOG2_ALPHA_INVERSE);
156:                                     mTouchCapPhy_TripValCalc(iScanChan);
9D0011B0  0B400476   J 0x9D0011D8
9D0011B4  00602021   ADDU A0, V1, ZERO
9D0011D4  00602021   ADDU A0, V1, ZERO
9D0011D8  AFA30018   SW V1, 24(SP)
9D0011DC  0F400404   JAL mTouchCapPhy_TripValCalc
9D0011E0  AFA60014   SW A2, 20(SP)
157:                 
158:                                     break;
9D0011E4  8FA30018   LW V1, 24(SP)
9D0011E8  0B400493   J 0x9D00124C
9D0011EC  8FA60014   LW A2, 20(SP)
159:                 
160:                                 case FILTER_METHOD_GATEDAVERAGE:
161:                                     if ( KEY_NOT_PRESSED == mTouchCapAPI_GetChannelTouchStatus(iScanChan,DECODE_METHOD_PRESS_ASSERT ))
9D001180  0B40047C   J 0x9D0011F0
9D001184  00602021   ADDU A0, V1, ZERO
9D0011F0  24050002   ADDIU A1, ZERO, 2
9D0011F4  AFA30018   SW V1, 24(SP)
9D0011F8  AFA60014   SW A2, 20(SP)
9D0011FC  0F400574   JAL mTouchCapAPI_GetChannelTouchStatus
9D001200  AFA70010   SW A3, 16(SP)
9D001204  8FA30018   LW V1, 24(SP)
9D001208  8FA60014   LW A2, 20(SP)
9D00120C  1440000F   BNE V0, ZERO, 0x9D00124C
9D001210  8FA70010   LW A3, 16(SP)
162:                                     {
163:                                         // Average in raw value.
164:                                         averageData[iScanChan] =
9D001220  94E50000   LHU A1, 0(A3)
9D001228  00052942   SRL A1, A1, 5
9D00122C  00852821   ADDU A1, A0, A1
9D001230  00042142   SRL A0, A0, 5
9D001234  00A42023   SUBU A0, A1, A0
9D001238  A4440000   SH A0, 0(V0)
165:                                             ( averageData[iScanChan] - (averageData[iScanChan]>>LOG2_ALPHA_INVERSE) )
9D001214  26020058   ADDIU V0, S0, 88
9D001218  00E21021   ADDU V0, A3, V0
9D001224  94440000   LHU A0, 0(V0)
166:                                             + (CurFiltdData[iScanChan]>>LOG2_ALPHA_INVERSE);
9D00121C  00F43821   ADDU A3, A3, S4
167:                                         mTouchCapPhy_TripValCalc(iScanChan);
9D00123C  0F400404   JAL mTouchCapPhy_TripValCalc
9D001240  00602021   ADDU A0, V1, ZERO
9D001244  8FA60014   LW A2, 20(SP)
9D001248  8FA30018   LW V1, 24(SP)
168:                                     }
169:                 
170:                                     break;
171:                 
172:                 
173:                             }//end switch(FilterType)
174:                         }//end if ( UpdateAverages == TRUE )
175:                 
176:                         AveragedData[iButton] = averageData[iScanChan];
9D00124C  8FA2004C   LW V0, 76(SP)
9D001250  00032040   SLL A0, V1, 1
9D001254  00512821   ADDU A1, V0, S1
9D001258  26020058   ADDIU V0, S0, 88
9D00125C  00821021   ADDU V0, A0, V0
9D001260  94470000   LHU A3, 0(V0)
9D001268  A4A70000   SH A3, 0(A1)
177:                 
178:                         // Calculate button weight as scaled fraction of averageData.
179:                         // 2^8 = 256 => full scale, i.e. equal to averageData
180:                         // The lower the  number the more the button is being pressed
181:                 
182:                         // Make sure ratio is never bigger than 1
183:                         ButtonRawData = CurFiltdData[iScanChan] < averageData[iScanChan] ? CurFiltdData[iScanChan] : averageData[iScanChan] ;
9D001264  00942021   ADDU A0, A0, S4
9D00126C  94420000   LHU V0, 0(V0)
9D001270  94870000   LHU A3, 0(A0)
9D00127C  00E02821   ADDU A1, A3, ZERO
9D001280  0047382B   SLTU A3, V0, A3
9D001284  54E00001   BNEL A3, ZERO, 0x9D00128C
9D001288  00402821   ADDU A1, V0, ZERO
184:                         if ( averageData[iScanChan] > 0 )
9D001274  10400016   BEQ V0, ZERO, 0x9D0012D0
9D001278  3C04A000   LUI A0, -24576
185:                         {
186:                              // Calculate button weight as a binary percentage, where 1/1 = 256 counts
187:                              ButtonWeightTemp = (UINT16)( ((UINT32)ButtonRawData<<8)/averageData[iScanChan] );
9D00128C  30A5FFFF   ANDI A1, A1, -1
9D001290  00052A00   SLL A1, A1, 8
9D001294  00A2001B   DIVU A1, V0
9D001298  004001F4   TEQ V0, ZERO
9D0012A8  00001012   MFLO V0, 0
9D0012AC  3042FFFF   ANDI V0, V0, -1
188:                              ButtonWeight[iButton] = ButtonWeightTemp;
9D00129C  00063840   SLL A3, A2, 1
9D0012A0  248500F0   ADDIU A1, A0, 240
9D0012A4  00E52821   ADDU A1, A3, A1
9D0012B0  A4A20000   SH V0, 0(A1)
189:                              if ( ButtonWeightTemp < MinButtonWeight )
9D0012B4  97850034   LHU A1, 52(GP)
9D0012B8  0045282B   SLTU A1, V0, A1
9D0012BC  50A0000A   BEQL A1, ZERO, 0x9D0012E8
9D0012C0  00061040   SLL V0, A2, 1
190:                              {
191:                                  MinButtonWeight = ButtonWeightTemp;
9D0012C4  A7820034   SH V0, 52(GP)
192:                                  iScanChanMinWeight = iScanChan;
9D0012C8  0B4004B9   J 0x9D0012E4
9D0012CC  A3830036   SB V1, 54(GP)
193:                              }
194:                         }
195:                         else
196:                         {
197:                             ButtonWeight[iButton] = 0XFFFF;
9D0012D0  00061840   SLL V1, A2, 1
9D0012D4  248200F0   ADDIU V0, A0, 240
9D0012D8  00621021   ADDU V0, V1, V0
9D0012DC  2403FFFF   ADDIU V1, ZERO, -1
9D0012E0  A4430000   SH V1, 0(V0)
198:                         }
199:                 
200:                         Weights[iButton] = ButtonWeight[iButton];
9D0012E4  00061040   SLL V0, A2, 1
9D0012E8  248400F0   ADDIU A0, A0, 240
9D0012EC  00442021   ADDU A0, V0, A0
9D0012F0  94820000   LHU V0, 0(A0)
9D0012F4  03D18821   ADDU S1, S8, S1
9D0012FC  A6220000   SH V0, 0(S1)
201:                 
202:                     }//end for(iButton=0; iButton<NumberScanChannels; iButton++)
203:                 
204:                 }
9D001314  8FBF0044   LW RA, 68(SP)
9D001318  8FBE0040   LW S8, 64(SP)
9D00131C  8FB7003C   LW S7, 60(SP)
9D001320  8FB60038   LW S6, 56(SP)
9D001324  8FB50034   LW S5, 52(SP)
9D001328  8FB40030   LW S4, 48(SP)
9D00132C  8FB3002C   LW S3, 44(SP)
9D001330  8FB20028   LW S2, 40(SP)
9D001334  8FB10024   LW S1, 36(SP)
9D001338  8FB00020   LW S0, 32(SP)
9D00133C  03E00008   JR RA
9D001340  27BD0048   ADDIU SP, SP, 72
205:                 
206:                 
207:                 /******************************************************************************
208:                  * Function:        void mTouchCapPhy_StablizeChannelData(void)
209:                  *
210:                  *****************************************************************************/
211:                 void mTouchCapPhy_StablizeChannelData(void)
212:                 {
9D001344  27BDFF70   ADDIU SP, SP, -144
9D001348  AFBF008C   SW RA, 140(SP)
9D00134C  AFB50088   SW S5, 136(SP)
9D001350  AFB40084   SW S4, 132(SP)
9D001354  AFB30080   SW S3, 128(SP)
9D001358  AFB2007C   SW S2, 124(SP)
9D00135C  AFB10078   SW S1, 120(SP)
9D001360  AFB00074   SW S0, 116(SP)
213:                 
214:                     UINT16 StartupCount;    // variable to 'discard' first N samples
215:                     UINT16 CurrentButtonMeasurements[MAX_ADC_CHANNELS],
216:                            CurrentAveragedMeasurements[MAX_ADC_CHANNELS],
217:                            CurrentWeights[MAX_ADC_CHANNELS];
218:                 
219:                     // Initialize averages with single measurement
220:                     while(!EmTouchDataReady);
9D001364  93820010   LBU V0, 16(GP)
9D001368  304200FF   ANDI V0, V0, 255
9D00136C  1040FFFD   BEQ V0, ZERO, 0x9D001364
9D001370  27B30034   ADDIU S3, SP, 52
221:                     mTouchCapPhy_UpdateData(CurrentButtonMeasurements,
9D001374  27B20050   ADDIU S2, SP, 80
9D001378  27B10018   ADDIU S1, SP, 24
9D00137C  24100001   ADDIU S0, ZERO, 1
9D001380  02202021   ADDU A0, S1, ZERO
9D001384  02602821   ADDU A1, S3, ZERO
9D001388  02403021   ADDU A2, S2, ZERO
9D00138C  24070001   ADDIU A3, ZERO, 1
9D001390  AFB00010   SW S0, 16(SP)
9D001394  0F40041C   JAL mTouchCapPhy_UpdateData
9D001398  3C15BF88   LUI S5, -16504
222:                                             CurrentAveragedMeasurements,
223:                                             CurrentWeights,
224:                                             TRUE, FILTER_METHOD_DONTAVERAGE);
225:                     EmTouchDataReady = 0;                //clear flag
9D00139C  A3800010   SB ZERO, 16(GP)
226:                     Set_ScanTimer_IE_Bit_State(ENABLE);  //Enable interrupt
9D0013A0  8EA21060   LW V0, 4192(S5)
9D0013A8  7E029CC4   INS V0, S0, 19, 1
9D0013AC  AEA21060   SW V0, 4192(S5)
227:                     Set_ScanTimer_ON_Bit_State(ENABLE);  //Run timer
9D0013A4  3C14BF80   LUI S4, -16512
9D0013B0  8E820C00   LW V0, 3072(S4)
9D0013B4  7E027BC4   INS V0, S0, 15, 1
9D0013B8  AE820C00   SW V0, 3072(S4)
228:                 
229:                 
230:                     StartupCount = STABILIZE_STARTUP_COUNT;
9D0013BC  24100080   ADDIU S0, ZERO, 128
231:                     while (StartupCount > 0)
9D001418  1600FFE9   BNE S0, ZERO, 0x9D0013C0
9D00141C  00000000   NOP
232:                     {
233:                         while(!EmTouchDataReady);
9D0013C0  93820010   LBU V0, 16(GP)
9D0013C4  304200FF   ANDI V0, V0, 255
9D0013C8  1040FFFD   BEQ V0, ZERO, 0x9D0013C0
9D0013CC  24020003   ADDIU V0, ZERO, 3
234:                         mTouchCapPhy_UpdateData(CurrentButtonMeasurements,
9D0013D0  02202021   ADDU A0, S1, ZERO
9D0013D4  02602821   ADDU A1, S3, ZERO
9D0013D8  02403021   ADDU A2, S2, ZERO
9D0013DC  24070001   ADDIU A3, ZERO, 1
9D0013E0  0F40041C   JAL mTouchCapPhy_UpdateData
9D0013E4  AFA20010   SW V0, 16(SP)
235:                                                 CurrentAveragedMeasurements,
236:                                                 CurrentWeights,
237:                                                 TRUE, FILTER_METHOD_SLOWAVERAGE);
238:                         StartupCount--;                      // Decr. N # times to establish startup
9D0013F4  2610FFFF   ADDIU S0, S0, -1
9D001404  3210FFFF   ANDI S0, S0, -1
239:                 
240:                         EmTouchDataReady = 0;                //clear flag
9D0013E8  A3800010   SB ZERO, 16(GP)
241:                         Set_ScanTimer_IE_Bit_State(ENABLE);  //Enable interrupt
9D0013EC  8EA21060   LW V0, 4192(S5)
9D0013F0  24050001   ADDIU A1, ZERO, 1
9D0013F8  7CA29CC4   INS V0, A1, 19, 1
9D0013FC  AEA21060   SW V0, 4192(S5)
9D001408  3C03BF88   LUI V1, -16504
242:                         Set_ScanTimer_ON_Bit_State(ENABLE);  //Run timer
9D001400  8E840C00   LW A0, 3072(S4)
9D00140C  7CA47BC4   INS A0, A1, 15, 1
9D001410  3C02BF80   LUI V0, -16512
9D001414  AE840C00   SW A0, 3072(S4)
243:                     }
244:                 
245:                     Set_ScanTimer_IE_Bit_State(DISABLE);  //Disable interrupt
9D001420  8C641060   LW A0, 4192(V1)
9D00142C  7C049CC4   INS A0, ZERO, 19, 1
9D001430  AC641060   SW A0, 4192(V1)
246:                     Set_ScanTimer_ON_Bit_State(DISABLE);  //Stop timer
9D001434  8C430C00   LW V1, 3072(V0)
9D001440  7C037BC4   INS V1, ZERO, 15, 1
9D001450  AC430C00   SW V1, 3072(V0)
247:                 
248:                 }
9D001424  8FBF008C   LW RA, 140(SP)
9D001428  8FB50088   LW S5, 136(SP)
9D001438  8FB40084   LW S4, 132(SP)
9D00143C  8FB30080   LW S3, 128(SP)
9D001444  8FB2007C   LW S2, 124(SP)
9D001448  8FB10078   LW S1, 120(SP)
9D00144C  8FB00074   LW S0, 116(SP)
9D001454  03E00008   JR RA
9D001458  27BD0090   ADDIU SP, SP, 144
249:                 
250:                 
251:                 /********************************************************************
252:                  * Function     :    void mTouchCapPhy_TripValCalc(WORD Index)
253:                  *
254:                  * PreCondition :    None
255:                  *
256:                  * Input        :    Index- Channel Number
257:                  *
258:                  * Output       :    None
259:                  *
260:                  * Side Effects :    None
261:                  *
262:                  * Overview     :    calculate the dynamic trip value.
263:                  *
264:                  *
265:                  * Note         :
266:                  *******************************************************************/
267:                 void mTouchCapPhy_TripValCalc(WORD Index)
268:                 {
9D001010  3084FFFF   ANDI A0, A0, -1
269:                 
270:                     tripValue[Index] = (averageData[Index] / KEYTRIPDIV);
9D001014  3C02A000   LUI V0, -24576
9D001018  00042040   SLL A0, A0, 1
9D00101C  24420058   ADDIU V0, V0, 88
9D001020  00821021   ADDU V0, A0, V0
9D001024  94430000   LHU V1, 0(V0)
9D001028  24020028   ADDIU V0, ZERO, 40
9D00102C  0062001B   DIVU V1, V0
9D001030  004001F4   TEQ V0, ZERO
9D001034  3C03A000   LUI V1, -24576
9D001038  2463003C   ADDIU V1, V1, 60
9D00103C  00831821   ADDU V1, A0, V1
9D001040  00001012   MFLO V0, 0
9D001044  3042FFFF   ANDI V0, V0, -1
9D001048  A4620000   SH V0, 0(V1)
271:                     hystValue[Index] = (tripValue[Index] / HYSTERESIS_VALUE);
9D00104C  3C03A000   LUI V1, -24576
9D001050  24630074   ADDIU V1, V1, 116
9D001054  00832021   ADDU A0, A0, V1
9D001058  24030032   ADDIU V1, ZERO, 50
9D00105C  0043001B   DIVU V0, V1
9D001060  006001F4   TEQ V1, ZERO
9D001064  00001812   MFLO V1, 0
272:                 
273:                 }
9D001068  03E00008   JR RA
9D00106C  A4830000   SH V1, 0(A0)
274:                 
275:                 /********************************************************************
276:                  * Function         :    void mTouchCapPhy_AdcSetup(void)
277:                  *
278:                  * PreCondition     :    None
279:                  *
280:                  * Input            :    None
281:                  *
282:                  * Output           :    None
283:                  *
284:                  * Side Effects     :    None
285:                  *
286:                  * Overview         :   This function will setup the ADC module
287:                  *
288:                  * Note             :   Does the necessary ADC peripheral setup.
289:                  *******************************************************************/
290:                 void mTouchCapPhy_AdcSetup(void)
291:                 {
292:                     mTouchCapADC_InitADC();
9D00145C  0B4008C8   J mTouchCapADC_InitADC
9D001460  00000000   NOP
9D00147C  0F4008C8   JAL mTouchCapADC_InitADC
9D001480  00000000   NOP
293:                 }
294:                 
295:                 /********************************************************************
296:                  * Function         :    void mTouchCapPhy_TickInit(void)
297:                  *
298:                  * PreCondition     :    None
299:                  *
300:                  * Input            :    None
301:                  *
302:                  * Output           :    None
303:                  *
304:                  * Side Effects     :    None
305:                  *
306:                  * Overview         :   This function will setup the Timer4 module
307:                  *
308:                  * Note             :   Does the necessary Timer4 peripheral setup except period.
309:                  *******************************************************************/
310:                 void mTouchCapPhy_TickInit(void)
311:                 {
312:                     mTouchCapTmr_InitTimer4();
9D001464  0B4006AC   J mTouchCapTmr_InitTimer4
9D001468  00000000   NOP
313:                 }
314:                 
315:                 /********************************************************************
316:                  * Function         :    void mTouchCapPhy_Initialize(void)
317:                  *
318:                  * PreCondition     :    None
319:                  *
320:                  * Input            :    None
321:                  *
322:                  * Output           :    None
323:                  *
324:                  * Side Effects     :    None
325:                  *
326:                  * Overview         :    Does the initialization of all peripherals/ports necessary for CVD operation.
327:                  *
328:                  *
329:                  * Note             :
330:                  *******************************************************************/
331:                 void mTouchCapPhy_Initialize(void)
332:                 {
9D00146C  27BDFFE8   ADDIU SP, SP, -24
9D001470  AFBF0014   SW RA, 20(SP)
333:                 
334:                     /* Initialize PORTs  */
335:                     mTouchCapApp_PortSetup();
9D001474  0F4008B1   JAL mTouchCapApp_PortSetup
9D001478  00000000   NOP
336:                 
337:                     /* Initialize ADC  */
338:                     mTouchCapPhy_AdcSetup();
339:                 
340:                     Set_Adc_Enable_State(ENABLE);
9D001484  3C02BF81   LUI V0, -16511
9D001488  8C439000   LW V1, -28672(V0)
9D001490  24040001   ADDIU A0, ZERO, 1
9D001494  7C837BC4   INS V1, A0, 15, 1
9D001498  AC439000   SW V1, -28672(V0)
341:                 
342:                 }
9D00148C  8FBF0014   LW RA, 20(SP)
9D00149C  03E00008   JR RA
9D0014A0  27BD0018   ADDIU SP, SP, 24
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/mTouchCapLib/mTouchCapLED.c  ---------------------------
1:                   /*****************************************************************************
2:                   * FileName:         mTouchCapLED.c
3:                   * Includes:
4:                   *   void mTouchCapLED_4ChDisplay(WORD Percent_Display)
5:                   *
6:                   *   void mTouchCapLED_PowerUpSequence(void)
7:                   *
8:                   *   static void mTouchCapLED_SetSliderLEDs_OnEvalBoard(SHORT input)
9:                   *   void mTouchCapLED_SetSliderLEDs(SHORT input)
10:                  *
11:                  *   static void mTouchCapLED_SetLED_OnEvalBoard(WORD LedNum)
12:                  *   void mTouchCapLED_SetLED(WORD LedNum)
13:                  *
14:                  * Software License Agreement
15:                  *
16:                  * Copyright © 2011 Microchip Technology Inc.
17:                  * Microchip licenses this software to you solely for use with Microchip
18:                  * products, according to the terms of the accompanying click-wrap software
19:                  * license. Microchip and its licensors retain all right, title and interest in
20:                  * and to the software.  All rights reserved. This software and any accompanying
21:                  * information is for suggestion only. It shall not be deemed to modify
22:                  * Microchip?s standard warranty for its products.  It is your responsibility to
23:                  * ensure that this software meets your requirements.
24:                  *
25:                  * SOFTWARE IS PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
26:                  * IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
27:                  * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL
28:                  * MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY DIRECT OR INDIRECT DAMAGES OR
29:                  * EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
30:                  * OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
31:                  * SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, OR ANY CLAIMS BY THIRD PARTIES
32:                  * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
33:                  *
34:                  * The aggregate and cumulative liability of Microchip and its licensors for
35:                  * damages related to the use of the software will in no event exceed $1000 or
36:                  * the amount you paid Microchip for the software, whichever is greater.
37:                  *
38:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
39:                  * TERMS AND THE TERMS OF THE ACCOMPANYING CLICK-WRAP SOFTWARE LICENSE.
40:                  *
41:                  * Change History:
42:                  * Author Date       Comments
43:                  *----------------------------------------------------------------------
44:                  * BDB    26-Jun-2008 First release
45:                  * SB     22-Oct-2008
46:                  * NK     24-Apr-2009 Porting for 18F46J50 Eval Board
47:                  * MC     22-Ian-2010 Porting for PIC32MX795F512H
48:                  * MWM       Mar-2011 Added comments, rearranged order of routines
49:                  * MWM    13 Sep 2011 Changed function prefix from mTouchCapAPI to mTouchCapLED
50:                  *******************************************************************************/
51:                  #include    "..\HardwareProfile.h"
52:                  #include    "..\mTouchConfig.h"
53:                  #include    "mTouchCapLED.h"
54:                  #include    "mTouchCapAPI.h"
55:                  #include    "..\Microchip\Include\TimeDelay.h"
56:                  
57:                  
58:                  #if defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
59:                      defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
60:                      static unsigned int LED_ARRAY1_IO[16] =
61:                          {
62:                           0x0001,0x0003,0x0007,0x000F,    //Green
63:                           0x001F,0x003F,0x007F,0x00FF,    //Yellow
64:                           0x0002,0x0003,0x4003,0x5003,    //Orange
65:                           0x7003,0xF003,0x0002,0x0006,    //Red
66:                           };
67:                      #if defined  (USE_DIRECT_KEYS) || defined (USE_MATRIX_KEYS)
68:                      static unsigned int LED_ARRAY2_IO[16] =
69:                          {
70:                           0x0001,0x0002,0x0004,0x0008,
71:                           0x0010,0x0020,0x0040,0x0080,
72:                           0x0002,0x0001,0x4000,0x1000,
73:                           0x2000,0x8000,0x0002,0x0004,
74:                           };
75:                      #endif
76:                  
77:                  #elif !defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD ) && \
78:                        !defined( PIC32MX220_STARTER_KIT_BOARD ) && \
79:                        !defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
80:                      static unsigned int LED_ARRAY1_IO[16] =
81:                          {
82:                           0x0001,0x0003,0x0007,0x000F,    //Green
83:                           0x001F,0x003F,0x007F,0x00FF,    //Yellow
84:                           0x0001,0x0003,0x0007,0x000F,    //Orange
85:                           0x001F,0x003F,0x007F,0x00FF,    //Red
86:                           };
87:                  #endif//!defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )...
88:                  
89:                  #if     !defined( PIC32MX220_STARTER_KIT_BOARD )
90:                  #  if     defined (USE_DIRECT_KEYS) || defined(USE_MATRIX_KEYS)
91:                      static SHORT PreviousLED = 0xFF; //storage of the last state of the
92:                  #  endif
93:                  #endif//!defined( PIC32MX220_STARTER_KIT_BOARD )
94:                  
95:                  /********************************************************************
96:                   * Function         :    void mTouchCapLED_4ChDisplay(WORD Percent_Display)
97:                   *
98:                   * PreCondition     :    None
99:                   *
100:                  * Input            :    Percent_Display - Percentage level of touch
101:                  *
102:                  * Output           :    None
103:                  *
104:                  * Side Effects     :    None
105:                  *
106:                  * Overview         :   The function will average out the samples and will
107:                  *                      send the filtered value of the finger position on the
108:                  *                      2 channel slider.
109:                  *
110:                  *
111:                  * Note             :
112:                  *******************************************************************/
113:                 #ifdef USE_SLIDER_4CHNL
114:                 #include "mTouchCapApp_FourChanSlider.h"
115:                 
116:                 // From mTouchCapApp_FourChanSlider.c
117:                 extern SHORT   pct_output_4Chl;
118:                 extern long    pct_sum_4Chl;
119:                 extern long    pct_array_4Chl[6];
120:                 
121:                 void mTouchCapLED_4ChDisplay(WORD Percent_Display)
122:                 {
123:                     WORD Index;
124:                     pct_output_4Chl = (SHORT)Percent_Display;
125:                     pct_sum_4Chl = pct_array_4Chl[0];           // Establish sum initially with first
126:                     for (Index=1; Index<6; Index++)
127:                     {
128:                         pct_sum_4Chl += pct_array_4Chl[Index];      // Calculate sum over iterations
129:                         pct_array_4Chl[Index-1] = pct_array_4Chl[Index];// Shift values
130:                     }
131:                     pct_array_4Chl[5] = pct_output_4Chl;
132:                 
133:                     pct_output_4Chl = pct_sum_4Chl/6;
134:                 
135:                 
136:                     if(pct_output_4Chl < 1)
137:                     {
138:                         mTouchCapLED_SetSliderLEDs(1);
139:                     }
140:                     else
141:                     {
142:                         mTouchCapLED_SetSliderLEDs(pct_output_4Chl);
143:                     }
144:                 }
145:                 #endif
146:                 
147:                 
148:                 /********************************************************************
149:                  * Function         :    void mTouchCapLED_PowerUpSequence(void)
150:                  *
151:                  * PreCondition     :    None
152:                  *
153:                  * Input            :    None
154:                  *
155:                  * Output           :    None
156:                  *
157:                  * Side Effects     :    None
158:                  *
159:                  * Overview         :   This function will turn ON the LEDs in the chaser sequence
160:                  *
161:                  * Note             :
162:                  *******************************************************************/
163:                 #if defined( PIC32MX220_STARTER_KIT_BOARD ) || \
164:                     defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD ) // No LEDs for power up
165:                 void mTouchCapLED_PowerUpSequence(void)
166:                 {
167:                     //Do Nothing
168:                 }
9D0023A8  03E00008   JR RA
9D0023AC  00000000   NOP
169:                 #else // Eval board has LEDs
170:                 void mTouchCapLED_PowerUpSequence(void)
171:                 {
172:                     INT16 DirFlag=+1;
173:                     WORD  ChaserCount=0;
174:                     WORD  runFlag = TRUE;
175:                 
176:                     while(runFlag)
177:                     {
178:                         DelayMs(20);
179:                 
180:                         if ( DirFlag == +1 )
181:                         {
182:                             ChaserCount++;
183:                             if(ChaserCount==100)
184:                             {
185:                                 DirFlag = -1;
186:                             }
187:                         }
188:                         else
189:                         {
190:                             ChaserCount--;
191:                             if(ChaserCount == 0)
192:                             {
193:                                 runFlag = FALSE;
194:                             }
195:                         }
196:                 
197:                         mTouchCapLED_SetSliderLEDs(ChaserCount);
198:                 
199:                         if(runFlag == FALSE)
200:                         {
201:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
202:                             PORTB = PORTB_ROW_NIL | PORTB_COL_NIL;
203:                             PORTC = PORTC_ROW_NIL | PORTC_COL_NIL;
204:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD )|| \
205:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
206:                             PORTD=0x00;
207:                             PORTG=0x00;
208:                             PORTC=0x00;
209:                 #          else
210:                             PORTD=0x0000;
211:                             PORTE=0x0000;
212:                 #          endif
213:                         }
214:                 
215:                     }
216:                 
217:                 }
218:                 #endif
219:                 
220:                 #if !defined( PIC32MX220_STARTER_KIT_BOARD ) && \
221:                     !defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
222:                 static void mTouchCapLED_SetSliderLEDs_OnEvalBoard(SHORT input)
223:                 {
224:                 
225:                     switch (input)
226:                     {
227:                         // Turn on LED1
228:                         case 1:
229:                         case 2:
230:                         case 3:
231:                         case 4:
232:                         case 5:
233:                         case 6:
234:                         case 7:
235:                         case 8:
236:                         case 9:
237:                         case 10:
238:                         case 11:
239:                         case 12:
240:                         case 13:
241:                         case 14:
242:                 #          if    defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
243:                             PORTB = PORTB_ROW_1 | PORTB_COL_1;
244:                             PORTC = PORTC_ROW_1 | PORTC_COL_1;
245:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
246:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
247:                             PORTD = LED_ARRAY1_IO[0]; Nop();
248:                             PORTG = 0;
249:                             PORTC = 0;
250:                 #          else
251:                             PORTD = LED_ARRAY1_IO[0];
252:                             PORTE = 0;
253:                 #          endif
254:                             break;
255:                 
256:                         // Turn on LEDs 1-2
257:                         case 15:
258:                         case 16:
259:                         case 17:
260:                         case 18:
261:                         case 19:
262:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
263:                             PORTB = PORTB_ROW_1 | PORTB_COL_2;
264:                             PORTC = PORTC_ROW_1 | PORTC_COL_2;
265:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
266:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
267:                             PORTD = LED_ARRAY1_IO[1]; Nop();
268:                             PORTG = 0;
269:                             PORTC = 0;
270:                 #          else
271:                             PORTD = LED_ARRAY1_IO[1];
272:                             PORTE = 0;
273:                 #          endif
274:                             break;
275:                 
276:                         // Turn on LEDs 1-3
277:                         case 20:
278:                         case 21:
279:                         case 22:
280:                         case 23:
281:                         case 24:
282:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
283:                             PORTB = PORTB_ROW_1 | PORTB_COL_3;
284:                             PORTC = PORTC_ROW_1 | PORTC_COL_3;
285:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
286:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
287:                             PORTD = LED_ARRAY1_IO[2]; Nop();
288:                             PORTG = 0;
289:                             PORTC = 0;
290:                 #          else
291:                             PORTD = LED_ARRAY1_IO[2];
292:                             PORTE = 0;
293:                 #          endif
294:                             break;
295:                 
296:                         // Turn on LEDs 1-4
297:                         case 25:
298:                         case 26:
299:                         case 27:
300:                         case 28:
301:                         case 29:
302:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
303:                             PORTB = PORTB_ROW_1 | PORTB_COL_4;
304:                             PORTC = PORTC_ROW_1 | PORTC_COL_4;
305:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
306:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
307:                             PORTD = LED_ARRAY1_IO[3]; Nop();
308:                             PORTG = 0;
309:                             PORTC = 0;
310:                 #          else
311:                             PORTD = LED_ARRAY1_IO[3];
312:                             PORTE = 0;
313:                 #          endif
314:                             break;
315:                 
316:                         // Turn on LEDs 1-5
317:                         case 30:
318:                         case 31:
319:                         case 32:
320:                         case 33:
321:                         case 34:
322:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
323:                             PORTB = PORTB_ROW_2 | PORTB_COL_1;
324:                             PORTC = PORTC_ROW_2 | PORTC_COL_1;
325:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
326:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
327:                             PORTD = LED_ARRAY1_IO[4]; Nop();
328:                             PORTG = 0;
329:                             PORTC = 0;
330:                 #          else
331:                             PORTD = LED_ARRAY1_IO[4];
332:                             PORTE = 0;
333:                 #          endif
334:                             break;
335:                 
336:                         // Turn on LEDs 1-6
337:                         case 35:
338:                         case 36:
339:                         case 37:
340:                         case 38:
341:                         case 39:
342:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
343:                             PORTB = PORTB_ROW_2 | PORTB_COL_2;
344:                             PORTC = PORTC_ROW_2 | PORTC_COL_2;
345:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
346:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
347:                             PORTD = LED_ARRAY1_IO[5]; Nop();
348:                             PORTG = 0;
349:                             PORTC = 0;
350:                 #          else
351:                             PORTD = LED_ARRAY1_IO[5];
352:                             PORTE = 0;
353:                 #          endif
354:                             break;
355:                 
356:                         // Turn on LEDs 1-7
357:                         case 40:
358:                         case 41:
359:                         case 42:
360:                         case 43:
361:                         case 44:
362:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
363:                             PORTB = PORTB_ROW_2 | PORTB_COL_3;
364:                             PORTC = PORTC_ROW_2 | PORTC_COL_3;
365:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
366:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
367:                             PORTD = LED_ARRAY1_IO[6]; Nop();
368:                             PORTG = 0;
369:                             PORTC = 0;
370:                 #          else
371:                             PORTD = LED_ARRAY1_IO[6];
372:                             PORTE = 0;
373:                 #          endif
374:                             break;
375:                 
376:                         // Turn on LEDs 1-8
377:                         case 45:
378:                         case 46:
379:                         case 47:
380:                         case 48:
381:                         case 49:
382:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
383:                             PORTB = PORTB_ROW_2 | PORTB_COL_4;
384:                             PORTC = PORTC_ROW_2 | PORTC_COL_4;
385:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
386:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
387:                             PORTD = LED_ARRAY1_IO[7]; Nop();
388:                             PORTG = 0;
389:                             PORTC = 0;
390:                 #          else
391:                             PORTD = LED_ARRAY1_IO[7];
392:                             PORTE = 0;
393:                 #          endif
394:                             break;
395:                 
396:                         // Turn on LEDs 1-9
397:                         case 50:
398:                         case 51:
399:                         case 52:
400:                         case 53:
401:                         case 54:
402:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
403:                             PORTB = PORTB_ROW_3 | PORTB_COL_1;
404:                             PORTC = PORTC_ROW_3 | PORTC_COL_1;
405:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
406:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
407:                             PORTD = LED_ARRAY1_IO[7]; Nop();
408:                             PORTG = LED_ARRAY1_IO[8]; Nop();
409:                             PORTC = 0;
410:                 #          else
411:                             PORTD = LED_ARRAY1_IO[7];
412:                             PORTE = LED_ARRAY1_IO[8];
413:                 #          endif
414:                             break;
415:                 
416:                         // Turn on LEDs 1-10
417:                         case 55:
418:                         case 56:
419:                         case 57:
420:                         case 58:
421:                         case 59:
422:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
423:                             PORTB = PORTB_ROW_3 | PORTB_COL_2;
424:                             PORTC = PORTC_ROW_3 | PORTC_COL_2;
425:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
426:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
427:                             PORTD = LED_ARRAY1_IO[7]; Nop();
428:                             PORTG = LED_ARRAY1_IO[9]; Nop();
429:                             PORTC = 0;
430:                 #          else
431:                             PORTD = LED_ARRAY1_IO[7];
432:                             PORTE = LED_ARRAY1_IO[9];
433:                 #          endif
434:                             break;
435:                 
436:                         // Turn on LEDs 1-11
437:                         case 60:
438:                         case 61:
439:                         case 62:
440:                         case 63:
441:                         case 64:
442:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
443:                             PORTB = PORTB_ROW_3 | PORTB_COL_3;
444:                             PORTC = PORTC_ROW_3 | PORTC_COL_3;
445:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
446:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
447:                             PORTD = LED_ARRAY1_IO[7];  Nop();
448:                             PORTG = LED_ARRAY1_IO[10]; Nop();
449:                             PORTC = 0;
450:                 #          else
451:                             PORTD = LED_ARRAY1_IO[7];
452:                             PORTE = LED_ARRAY1_IO[10];
453:                 #          endif
454:                             break;
455:                 
456:                         // Turn on LEDs 1-12
457:                         case 65:
458:                         case 66:
459:                         case 67:
460:                         case 68:
461:                         case 69:
462:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
463:                             PORTB = PORTB_ROW_3 | PORTB_COL_4;
464:                             PORTC = PORTC_ROW_3 | PORTC_COL_4;
465:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
466:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
467:                             PORTD = LED_ARRAY1_IO[7];  Nop();
468:                             PORTG = LED_ARRAY1_IO[11]; Nop();
469:                             PORTC = 0;
470:                 #          else
471:                             PORTD = LED_ARRAY1_IO[7];
472:                             PORTE = LED_ARRAY1_IO[11];
473:                 #          endif
474:                             break;
475:                 
476:                         // Turn on LEDs 1-13
477:                         case 70:
478:                         case 71:
479:                         case 72:
480:                         case 73:
481:                         case 74:
482:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
483:                             PORTB = PORTB_ROW_4 | PORTB_COL_1;
484:                             PORTC = PORTC_ROW_4 | PORTC_COL_1;
485:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
486:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
487:                             PORTD = LED_ARRAY1_IO[7];  Nop();
488:                             PORTG = LED_ARRAY1_IO[12]; Nop();
489:                             PORTC = 0;
490:                 #          else
491:                             PORTD = LED_ARRAY1_IO[7];
492:                             PORTE = LED_ARRAY1_IO[12];
493:                 #          endif
494:                             break;
495:                 
496:                         // Turn on LEDs 1-14
497:                         case 75:
498:                         case 76:
499:                         case 77:
500:                         case 78:
501:                         case 79:
502:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
503:                             PORTB = PORTB_ROW_4 | PORTB_COL_2;
504:                             PORTC = PORTC_ROW_4 | PORTC_COL_2;
505:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
506:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
507:                             PORTD = LED_ARRAY1_IO[7];  Nop();
508:                             PORTG = LED_ARRAY1_IO[13]; Nop();
509:                             PORTC = 0;
510:                 #          else
511:                             PORTD = LED_ARRAY1_IO[7];
512:                             PORTE = LED_ARRAY1_IO[13];
513:                 #          endif
514:                             break;
515:                 
516:                         // Turn on LEDs 1-15
517:                         case 80:
518:                         case 81:
519:                         case 82:
520:                         case 83:
521:                         case 84:
522:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
523:                             PORTB = PORTB_ROW_4 | PORTB_COL_3;
524:                             PORTC = PORTC_ROW_4 | PORTC_COL_3;
525:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
526:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
527:                             PORTD = LED_ARRAY1_IO[7];  Nop();
528:                             PORTG = LED_ARRAY1_IO[13]; Nop();
529:                             PORTC = LED_ARRAY1_IO[14]; Nop();
530:                 #          else
531:                             PORTD = LED_ARRAY1_IO[7];
532:                             PORTE = LED_ARRAY1_IO[14];
533:                 #          endif
534:                             break;
535:                 
536:                         // Turn on LEDs 1-16
537:                         case 85:
538:                         case 86:
539:                         case 87:
540:                         case 88:
541:                         case 89:
542:                         case 90:
543:                         case 91:
544:                         case 92:
545:                         case 93:
546:                         case 94:
547:                         case 95:
548:                         case 96:
549:                         case 97:
550:                         case 98:
551:                         case 99:
552:                         case 100:
553:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
554:                             PORTB = PORTB_ROW_4 | PORTB_COL_4;
555:                             PORTC = PORTC_ROW_4 | PORTC_COL_4;
556:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
557:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
558:                             PORTD = LED_ARRAY1_IO[7];  Nop();
559:                             PORTG = LED_ARRAY1_IO[13]; Nop();
560:                             PORTC = LED_ARRAY1_IO[15]; Nop();
561:                 #          else
562:                             PORTD = LED_ARRAY1_IO[7];
563:                             PORTE = LED_ARRAY1_IO[15];
564:                 #          endif
565:                             break;
566:                 
567:                         default:
568:                 #          if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
569:                             PORTB = PORTB_ROW_NIL | PORTB_COL_NIL;
570:                             PORTC = PORTC_ROW_NIL | PORTC_COL_NIL;
571:                 #          elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
572:                                 defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
573:                             PORTD = 0;
574:                             PORTG = 0;
575:                             PORTC = 0;
576:                 #          else
577:                             PORTD = 0;
578:                             PORTE = 0;
579:                 #          endif
580:                             break;
581:                 
582:                     }
583:                 
584:                 }
585:                 #endif//!defined( PIC32MX220_STARTER_KIT_BOARD )...
586:                 
587:                 /********************************************************************
588:                  * Function         :    void mTouchCapLED_SetSliderLEDs(SHORT input)
589:                  *
590:                  * PreCondition     :    None
591:                  *
592:                  * Input            :    input - Position of the finger on the slider in terms of percentage(0-100)
593:                  *
594:                  * Output           :    None
595:                  *
596:                  * Side Effects     :    None
597:                  *
598:                  * Overview         :    Invokes the appropriate LED display function based on PIC controller selected.
599:                  *
600:                  *
601:                  *
602:                  * Note             :
603:                  *******************************************************************/
604:                 void mTouchCapLED_SetSliderLEDs(SHORT input)
605:                 {
606:                 #if !defined( PIC32MX220_STARTER_KIT_BOARD ) && \
607:                     !defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
608:                     /* Call PIC32MX LED display function */
609:                     mTouchCapLED_SetSliderLEDs_OnEvalBoard(input);
610:                 #else
611:                     //Do Nothing - starter kit board doesn't have LEDs.
612:                 #endif
613:                 }
9D0023B0  03E00008   JR RA
9D0023B4  00000000   NOP
614:                 
615:                 
616:                 /********************************************************************
617:                  * Function         :    void mTouchCapLED_SetLED_OnEvalBoard(WORD LedNum)
618:                  *
619:                  * PreCondition     :    None
620:                  *
621:                  * Input            :    The LED number that has to be displayed.
622:                  *
623:                  * Output           :    None
624:                  *
625:                  * Side Effects     :    None
626:                  *
627:                  * Overview         :    This function will turn on the LED in the PIC32 CVD Eval Board
628:                  *                       based on the input that is passed to the function
629:                  *
630:                  *
631:                  * Note             :
632:                  *******************************************************************/
633:                 #if !defined( PIC32MX220_STARTER_KIT_BOARD ) && \
634:                     defined (USE_DIRECT_KEYS) || defined(USE_MATRIX_KEYS)
635:                 static void mTouchCapLED_SetLED_OnEvalBoard(WORD LedNum)
636:                 {
637:                 
638:                     if(PreviousLED != LedNum)      //check for new value to prevent flicker of LEDS
639:                     {
640:                         switch(LedNum)
641:                         {
642:                             case LED_1:
643:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
644:                                 PORTB = PORTB_ROW_1 | PORTB_COL_1;
645:                                 PORTC = PORTC_ROW_1 | PORTC_COL_1;
646:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
647:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
648:                                 PORTD = LED_ARRAY2_IO[0]; Nop();
649:                                 PORTG = 0;
650:                                 PORTC = 0;
651:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
652:                                 PORTC = 1<<2; // Left Arrow
653:                                 PORTD = 1<<7; // General Purpose LED Array
654:                 #              else
655:                                 PORTD=0x0001;
656:                                 PORTE=0x0000;
657:                 #              endif
658:                                 break;
659:                 
660:                             case LED_2:
661:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
662:                                 PORTB = PORTB_ROW_1 | PORTB_COL_2;
663:                                 PORTC = PORTC_ROW_1 | PORTC_COL_2;
664:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
665:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
666:                                 PORTD = LED_ARRAY2_IO[1]; Nop();
667:                                 PORTG = 0;
668:                                 PORTC = 0;
669:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
670:                                 PORTC = 1<<4; // Down Arrow
671:                                 PORTD = 1<<8; // General Purpose LED Array
672:                 #              else
673:                                 PORTD=0x0002;
674:                                 PORTE=0x0000;
675:                 #              endif
676:                                 break;
677:                 
678:                             case LED_3:
679:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
680:                                 PORTB = PORTB_ROW_1 | PORTB_COL_3;
681:                                 PORTC = PORTC_ROW_1 | PORTC_COL_3;
682:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
683:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
684:                                 PORTD = LED_ARRAY2_IO[2]; Nop();
685:                                 PORTG = 0;
686:                                 PORTC = 0;
687:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
688:                                 PORTC = 0;    // Enter (Central) Key
689:                                 PORTD = 1<<9; // General Purpose LED Array
690:                 #              else
691:                                 PORTD=0x0004;
692:                                 PORTE=0x0000;
693:                 #              endif
694:                                 break;
695:                 
696:                             case LED_4:
697:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
698:                                 PORTB = PORTB_ROW_1 | PORTB_COL_4;
699:                                 PORTC = PORTC_ROW_1 | PORTC_COL_4;
700:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
701:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
702:                                 PORTD = LED_ARRAY2_IO[3]; Nop();
703:                                 PORTG = 0;
704:                                 PORTC = 0;
705:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
706:                                 PORTC = 1<<3;  // Right Arrow
707:                                 PORTD = 1<<10; // General Purpose LED Array
708:                 #              else
709:                                 PORTD=0x0008;
710:                                 PORTE=0x0000;
711:                 #              endif
712:                                 break;
713:                 
714:                             case LED_5:
715:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
716:                                 PORTB = PORTB_ROW_2 | PORTB_COL_1;
717:                                 PORTC = PORTC_ROW_2 | PORTC_COL_1;
718:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
719:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
720:                                 PORTD = LED_ARRAY2_IO[4]; Nop();
721:                                 PORTG = 0;
722:                                 PORTC = 0;
723:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
724:                                 PORTC = 1<<1;     // Up  Arrow
725:                                 PORTD = 1<<11; // General Purpose LED Array
726:                 #              else
727:                                 PORTD=0x0010;
728:                                 PORTE=0x0000;
729:                 #              endif
730:                                 break;
731:                 
732:                             case LED_6:
733:                 #             if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
734:                                 PORTB = PORTB_ROW_2 | PORTB_COL_2;
735:                                 PORTC = PORTC_ROW_2 | PORTC_COL_2;
736:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
737:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
738:                                 PORTD = LED_ARRAY2_IO[5]; Nop();
739:                                 PORTG = 0;
740:                                 PORTC = 0;
741:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
742:                                 PORTC = 0;
743:                                 PORTD = 1<<12; // General Purpose LED Array
744:                 #              else
745:                                 PORTD=0x0020;
746:                                 PORTE=0x0000;
747:                 #              endif
748:                                 break;
749:                 
750:                             case LED_7:
751:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
752:                                 PORTB = PORTB_ROW_2 | PORTB_COL_3;
753:                                 PORTC = PORTC_ROW_2 | PORTC_COL_3;
754:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
755:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
756:                                 PORTD = LED_ARRAY2_IO[6]; Nop();
757:                                 PORTG = 0;
758:                                 PORTC = 0;
759:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
760:                                 PORTC = 0;
761:                                 PORTD = 1<<5; // General Purpose LED Array
762:                 #              else
763:                                 PORTD=0x0040;
764:                                 PORTE=0x0000;
765:                 #              endif
766:                                 break;
767:                 
768:                             case LED_8:
769:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
770:                                 PORTB = PORTB_ROW_2 | PORTB_COL_4;
771:                                 PORTC = PORTC_ROW_2 | PORTC_COL_4;
772:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
773:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
774:                                 PORTD = LED_ARRAY2_IO[7];
775:                                 PORTG = 0;
776:                                 PORTC = 0;
777:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
778:                                 PORTC = 0;
779:                                 PORTD = 1<<6; // General Purpose LED Array
780:                 #              else
781:                                 PORTD=0x0080;
782:                                 PORTE=0x0000;
783:                 #              endif
784:                                 break;
785:                 
786:                             case LED_9:
787:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
788:                                 PORTB = PORTB_ROW_3 | PORTB_COL_1;
789:                                 PORTC = PORTC_ROW_3 | PORTC_COL_1;
790:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
791:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
792:                                 PORTD = 0;
793:                                 PORTG = LED_ARRAY2_IO[8];
794:                                 PORTC = 0;
795:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
796:                                 // Do Nothing
797:                 #              else
798:                                 PORTD=0x0000;
799:                                 PORTE=0x0001;
800:                 #              endif
801:                                 break;
802:                 
803:                             case LED_10:
804:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
805:                                 PORTB = PORTB_ROW_3 | PORTB_COL_2;
806:                                 PORTC = PORTC_ROW_3 | PORTC_COL_2;
807:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
808:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
809:                                 PORTD = 0;
810:                                 PORTG = LED_ARRAY2_IO[9];
811:                                 PORTC = 0;
812:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
813:                                 // Do Nothing
814:                 #              else
815:                                 PORTD=0x0000;
816:                                 PORTE=0x0002;
817:                 #              endif
818:                                 break;
819:                 
820:                             case LED_11:
821:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
822:                                 PORTB = PORTB_ROW_3 | PORTB_COL_3;
823:                                 PORTC = PORTC_ROW_3 | PORTC_COL_3;
824:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
825:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
826:                                 PORTD = 0;
827:                                 PORTG = LED_ARRAY2_IO[10];
828:                                 PORTC = 0;
829:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
830:                                 // Do Nothing
831:                 #              else
832:                                 PORTD=0x0000;
833:                                 PORTE=0x0004;
834:                 #              endif
835:                                 break;
836:                 
837:                             case LED_12:
838:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
839:                                 PORTB = PORTB_ROW_3 | PORTB_COL_4;
840:                                 PORTC = PORTC_ROW_3 | PORTC_COL_4;
841:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
842:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
843:                                 PORTD = 0;
844:                                 PORTG = LED_ARRAY2_IO[11];
845:                                 PORTC = 0;
846:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
847:                                 // Do Nothing
848:                 #              else
849:                                 PORTD=0x0000;
850:                                 PORTE=0x0008;
851:                 #              endif
852:                                 break;
853:                 
854:                             case LED_13:
855:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
856:                                 PORTB = PORTB_ROW_4 | PORTB_COL_1;
857:                                 PORTC = PORTC_ROW_4 | PORTC_COL_1;
858:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
859:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
860:                                 PORTD = 0;
861:                                 PORTG = LED_ARRAY2_IO[12];
862:                                 PORTC = 0;
863:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
864:                                 // Do Nothing
865:                 #              else
866:                                 PORTD=0x0000;
867:                                 PORTE=0x0010;
868:                 #              endif
869:                                 break;
870:                 
871:                             case LED_14:
872:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
873:                                 PORTB = PORTB_ROW_4 | PORTB_COL_2;
874:                                 PORTC = PORTC_ROW_4 | PORTC_COL_2;
875:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
876:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
877:                                 PORTD = 0;
878:                                 PORTG = LED_ARRAY2_IO[13];
879:                                 PORTC = 0;
880:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
881:                                 // Do Nothing
882:                 #              else
883:                                 PORTD=0x0000;
884:                                 PORTE=0x0020;
885:                 #              endif
886:                                 break;
887:                 
888:                             case LED_15:
889:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
890:                                 PORTB = PORTB_ROW_4 | PORTB_COL_3;
891:                                 PORTC = PORTC_ROW_4 | PORTC_COL_3;
892:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
893:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
894:                                 PORTD = 0;
895:                                 PORTG = 0;
896:                                 PORTC = LED_ARRAY2_IO[14];
897:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
898:                                 // Do Nothing
899:                 #              else
900:                                 PORTD=0x0000;
901:                                 PORTE=0x0040;
902:                 #              endif
903:                                 break;
904:                 
905:                             case LED_16:
906:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
907:                                 PORTB = PORTB_ROW_4 | PORTB_COL_4;
908:                                 PORTC = PORTC_ROW_4 | PORTC_COL_4;
909:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
910:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
911:                                 PORTD = 0;
912:                                 PORTG = 0;
913:                                 PORTC = LED_ARRAY2_IO[15];
914:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
915:                                 // Do Nothing
916:                 #              else
917:                                 PORTD=0x0000;
918:                                 PORTE=0x0080;
919:                 #              endif
920:                                 break;
921:                 
922:                             default:
923:                 #              if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
924:                                 PORTB = PORTB_ROW_NIL | PORTB_COL_NIL;
925:                                 PORTC = PORTC_ROW_NIL | PORTC_COL_NIL;
926:                 #              elif defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
927:                                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
928:                                 PORTD = 0;
929:                                 PORTG = 0;
930:                                 PORTC = 0;
931:                 #              elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
932:                                 PORTC = 0; // 5 Key Star
933:                                 PORTD = 0; // General Purpose LED Array
934:                 #              else
935:                                 PORTD=0x0000;
936:                                 PORTE=0x0000;
937:                 #              endif
938:                                 break;
939:                 
940:                         }
941:                 
942:                         /* Back it up  */
943:                         PreviousLED = LedNum;
944:                 
945:                     }//if(PreviousLED != LedNum)
946:                 }
947:                 #endif//!defined( PIC32MX220_STARTER_KIT_BOARD )
948:                 
949:                 
950:                 /********************************************************************
951:                  * Function         :    void mTouchCapLED_SetLED(WORD LedNum)
952:                  *
953:                  * PreCondition     :    None
954:                  *
955:                  * Input            :    The LED number that has to be displayed.
956:                  *
957:                  * Output           :    None
958:                  *
959:                  * Side Effects     :    None
960:                  *
961:                  * Overview         : Invokes the appropriate display function based on PIC controller selected.
962:                  *
963:                  *
964:                  * Note             :
965:                  *******************************************************************/
966:                 #if defined (USE_DIRECT_KEYS) || defined(USE_MATRIX_KEYS)
967:                 void mTouchCapLED_SetLED(WORD LedNum)
968:                 {
969:                 #  if defined( PIC32MX220_STARTER_KIT_BOARD )
970:                     //Do nothing - board doesn't have LEDs
971:                 #  else
972:                     mTouchCapLED_SetLED_OnEvalBoard(LedNum);
973:                 #  endif
974:                 }
9D0023B8  03E00008   JR RA
9D0023BC  00000000   NOP
975:                 #endif
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/mTouchCapLib/mTouchCapApp_DirectKeys.c  ----------------
1:                   
2:                   /*****************************************************************************
3:                   * FileName:         mTouchCapApp_DirectKeys.c
4:                   * Includes:
5:                   *   void mTouchCapApp_DirectKeys_Demo(void)
6:                   *   void mTouchCapApp_DirectKeys_Create(void)
7:                   *
8:                   * Dependencies:
9:                   * Processor:        PIC32
10:                  * Compiler:         C32
11:                  * Company:          Microchip Technology Incorporated
12:                  *
13:                  * Software License Agreement
14:                  *
15:                  * Copyright © 2011 Microchip Technology Inc.
16:                  * Microchip licenses this software to you solely for use with Microchip
17:                  * products, according to the terms of the accompanying click-wrap software
18:                  * license. Microchip and its licensors retain all right, title and interest in
19:                  * and to the software.  All rights reserved. This software and any accompanying
20:                  * information is for suggestion only. It shall not be deemed to modify
21:                  * Microchip?s standard warranty for its products.  It is your responsibility to
22:                  * ensure that this software meets your requirements.
23:                  *
24:                  * SOFTWARE IS PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
25:                  * IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
26:                  * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL
27:                  * MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY DIRECT OR INDIRECT DAMAGES OR
28:                  * EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
29:                  * OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
30:                  * SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, OR ANY CLAIMS BY THIRD PARTIES
31:                  * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
32:                  *
33:                  * The aggregate and cumulative liability of Microchip and its licensors for
34:                  * damages related to the use of the software will in no event exceed $1000 or
35:                  * the amount you paid Microchip for the software, whichever is greater.
36:                  *
37:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
38:                  * TERMS AND THE TERMS OF THE ACCOMPANYING CLICK-WRAP SOFTWARE LICENSE.
39:                  *
40:                  * Author                Date           Comment
41:                  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
42:                  * BDB                   26 Jun 2008    First Version for CTMU EVAL Board
43:                  * SB                    22 Oct 2008    Updates to First Version
44:                  * Naveen. M             14 Apr 2009    Version 0.1 Initial Draft
45:                  * Sasha. M  / Naveen. M 4 May 2009     Version 0.2 Updates
46:                  * Sasha. M  / Naveen. M 11 Nov 2009    Version 1.0 Release
47:                  * Sasha. M  / Nithin.   10 April 2010  Version 1.20 Release
48:                  * MWM                      March 2011
49:                  *   Changed mTouchCapApp_DirectKeys_Demo to support multi-touch
50:                  *   Simplified mTouchCapApp_DirectKeys_Create
51:                  *****************************************************************************/
52:                  
53:                  
54:                  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
55:                  /* ~~~~~~~~~~~~~~~~~~~~~    Includes    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     */
56:                  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
57:                  #include    "..\mTouchConfig.h"
58:                  #include    "..\HardwareProfile.h"
59:                  #include    "mTouchCapAPI.h"
60:                  #include    "mTouchCapLED.h"
61:                  #include    "mTouchCapPhy.h"
62:                  
63:                  DIRECTKEY DirectKey1;
64:                  DIRECTKEY DirectKey2;
65:                  DIRECTKEY DirectKey3;
66:                  DIRECTKEY DirectKey4;
67:                  #if     !defined( PIC32MX220_STARTER_KIT_BOARD )
68:                  DIRECTKEY DirectKey5;
69:                  # if     !defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
70:                  DIRECTKEY DirectKey6;
71:                  DIRECTKEY DirectKey7;
72:                  DIRECTKEY DirectKey8;
73:                  # endif//!defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
74:                  #endif//!defined( PIC32MX220_STARTER_KIT_BOARD )
75:                  
76:                  /********************************************************************
77:                   * Function         :    void mTouchCapApp_DirectKeys_Demo(void)
78:                   *
79:                   * PreCondition     :    None
80:                   *
81:                   * Input            :    None
82:                   *
83:                   * Output           :    None
84:                   *
85:                   * Side Effects     :    None
86:                   *
87:                   * Overview         :   This function will demonstrate the usage of the API's
88:                   *                      that is associated with the Direct key Demo Board
89:                   *
90:                   * Note         :
91:                   *******************************************************************/
92:                  UINT16 mTouchCapApp_DirectKeys_Demo(void)
93:                  {
9D001EA4  27BDFFE8   ADDIU SP, SP, -24
9D001EA8  AFB00010   SW S0, 16(SP)
9D001EAC  AFBF0014   SW RA, 20(SP)
94:                      UINT16 ButtonStatus = 0;
95:                  
96:                  
97:                      if(KEY_PRESSED ==
9D001EB8  24030001   ADDIU V1, ZERO, 1
9D001EBC  14430005   BNE V0, V1, 0x9D001ED4
9D001EC0  93840014   LBU A0, 20(GP)
98:                           mTouchCapAPI_GetChannelTouchStatus(DirectKey1.Channel_Num,
9D001E9C  93840024   LBU A0, 36(GP)
9D001EA0  9385002B   LBU A1, 43(GP)
9D001EB0  0F400574   JAL mTouchCapAPI_GetChannelTouchStatus
9D001EB4  00008021   ADDU S0, ZERO, ZERO
99:                                                              DirectKey1.DecodeMethod) )
100:                     {
101:                 #      if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
102:                         mTouchCapLED_SetLED(LED_1);
103:                 #      elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
104:                         mTouchCapLED_SetLED(LED_1);
105:                 #      else
106:                         mTouchCapLED_SetLED(LED_8);
9D001EC4  0F4008EE   JAL mTouchCapLED_SetLED
9D001EC8  24040007   ADDIU A0, ZERO, 7
107:                 #      endif
108:                         ButtonStatus += 1;
9D001ECC  24100001   ADDIU S0, ZERO, 1
109:                     }
110:                 
111:                     if(KEY_PRESSED ==
9D001EDC  24030001   ADDIU V1, ZERO, 1
9D001EE0  14430006   BNE V0, V1, 0x9D001EFC
9D001EE4  9384001C   LBU A0, 28(GP)
112:                          mTouchCapAPI_GetChannelTouchStatus(DirectKey2.Channel_Num,
9D001ED0  93840014   LBU A0, 20(GP)
9D001ED4  0F400574   JAL mTouchCapAPI_GetChannelTouchStatus
9D001ED8  9385001B   LBU A1, 27(GP)
113:                                                             DirectKey2.DecodeMethod) )
114:                     {
115:                 #      if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
116:                         mTouchCapLED_SetLED(LED_2);
117:                 #      elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
118:                         mTouchCapLED_SetLED(LED_2);
119:                 #      else
120:                         mTouchCapLED_SetLED(LED_9);
9D001EE8  24040008   ADDIU A0, ZERO, 8
9D001EEC  0F4008EE   JAL mTouchCapLED_SetLED
9D001EF0  26100002   ADDIU S0, S0, 2
121:                 #      endif
122:                         ButtonStatus += 2;
9D001EF4  3210FFFF   ANDI S0, S0, -1
123:                     }
124:                 
125:                     if(KEY_PRESSED ==
9D001F04  24030001   ADDIU V1, ZERO, 1
9D001F08  14430006   BNE V0, V1, 0x9D001F24
9D001F0C  9384002C   LBU A0, 44(GP)
126:                          mTouchCapAPI_GetChannelTouchStatus(DirectKey3.Channel_Num,
9D001EF8  9384001C   LBU A0, 28(GP)
9D001EFC  0F400574   JAL mTouchCapAPI_GetChannelTouchStatus
9D001F00  93850023   LBU A1, 35(GP)
127:                                                             DirectKey3.DecodeMethod) )
128:                     {
129:                 #      if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
130:                         mTouchCapLED_SetLED(LED_3);
131:                 #      elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
132:                         mTouchCapLED_SetLED(LED_3);
133:                 #      else
134:                         mTouchCapLED_SetLED(LED_10);
9D001F10  24040009   ADDIU A0, ZERO, 9
9D001F14  0F4008EE   JAL mTouchCapLED_SetLED
9D001F18  26100004   ADDIU S0, S0, 4
135:                 #      endif
136:                         ButtonStatus += 4;
9D001F1C  3210FFFF   ANDI S0, S0, -1
137:                     }
138:                 
139:                     if(KEY_PRESSED ==
9D001F2C  24030001   ADDIU V1, ZERO, 1
9D001F30  14430005   BNE V0, V1, 0x9D001F48
9D001F34  2404000A   ADDIU A0, ZERO, 10
140:                          mTouchCapAPI_GetChannelTouchStatus(DirectKey4.Channel_Num,
9D001F20  9384002C   LBU A0, 44(GP)
9D001F24  0F400574   JAL mTouchCapAPI_GetChannelTouchStatus
9D001F28  93850033   LBU A1, 51(GP)
141:                                                             DirectKey4.DecodeMethod) )
142:                     {
143:                 #      if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
144:                         mTouchCapLED_SetLED(LED_4);
145:                 #      elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
146:                         mTouchCapLED_SetLED(LED_4);
147:                 #      else
148:                         mTouchCapLED_SetLED(LED_11);
9D001F38  0F4008EE   JAL mTouchCapLED_SetLED
9D001F3C  26100008   ADDIU S0, S0, 8
149:                 #      endif
150:                         ButtonStatus += 8;
9D001F40  0B4007D6   J 0x9D001F58
9D001F44  3210FFFF   ANDI S0, S0, -1
151:                     }
152:                 
153:                     // Starter PIC32MX220F032D kit board has only 4 buttons
154:                 #if !defined( PIC32MX220_STARTER_KIT_BOARD )
155:                     if(KEY_PRESSED ==
156:                          mTouchCapAPI_GetChannelTouchStatus(DirectKey5.Channel_Num,
157:                                                             DirectKey5.DecodeMethod) )
158:                     {
159:                 #      if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
160:                         mTouchCapLED_SetLED(LED_5);
161:                 #      elif defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
162:                         mTouchCapLED_SetLED(LED_5);
163:                 #      else
164:                         mTouchCapLED_SetLED(LED_12);
165:                 #      endif
166:                         ButtonStatus += 16;
167:                     }
168:                 
169:                     // One Pic Microcontroller Platform Demo Board has only 5 buttons
170:                 # if !defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
171:                     if(KEY_PRESSED ==
172:                          mTouchCapAPI_GetChannelTouchStatus(DirectKey6.Channel_Num,
173:                                                             DirectKey6.DecodeMethod) )
174:                     {
175:                 #      if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
176:                         mTouchCapLED_SetLED(LED_6);
177:                 #      else
178:                         mTouchCapLED_SetLED(LED_13);
179:                 #      endif
180:                         ButtonStatus += 32;
181:                     }
182:                 
183:                     if(KEY_PRESSED ==
184:                          mTouchCapAPI_GetChannelTouchStatus(DirectKey7.Channel_Num,
185:                                                             DirectKey7.DecodeMethod) )
186:                     {
187:                 #      if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
188:                         mTouchCapLED_SetLED(LED_7);
189:                 #      else
190:                         mTouchCapLED_SetLED(LED_14);
191:                 #      endif
192:                         ButtonStatus += 64;
193:                     }
194:                 
195:                     if(KEY_PRESSED ==
196:                          mTouchCapAPI_GetChannelTouchStatus(DirectKey8.Channel_Num,
197:                                                             DirectKey8.DecodeMethod) )
198:                     {
199:                 #      if defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD )
200:                         mTouchCapLED_SetLED(LED_8);
201:                 #      else
202:                         mTouchCapLED_SetLED(LED_15);
203:                 #      endif
204:                         ButtonStatus += 128;
205:                     }
206:                 # endif//!defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
207:                 #endif//!defined( PIC32MX220_STARTER_KIT_BOARD )
208:                 
209:                     if ( ButtonStatus == 0 )
9D001F48  16000004   BNE S0, ZERO, 0x9D001F5C
9D001F4C  8FBF0014   LW RA, 20(SP)
210:                     {
211:                         mTouchCapLED_SetLED(LED_NIL);
9D001F50  0F4008EE   JAL mTouchCapLED_SetLED
9D001F54  24040010   ADDIU A0, ZERO, 16
212:                     }
213:                 
214:                     return ButtonStatus;
215:                 }
9D001F58  8FBF0014   LW RA, 20(SP)
9D001F5C  02001021   ADDU V0, S0, ZERO
9D001F60  8FB00010   LW S0, 16(SP)
9D001F64  03E00008   JR RA
9D001F68  27BD0018   ADDIU SP, SP, 24
216:                 
217:                 /********************************************************************
218:                  * Function         :     void mTouchCapApp_DirectKeys_Create(void)
219:                  *
220:                  * PreCondition     :    None
221:                  *
222:                  * Input            :    None
223:                  *
224:                  * Output           :    None
225:                  *
226:                  * Side Effects     :    None
227:                  *
228:                  * Overview         :   This function fills the direct keys conf struct
229:                  *
230:                  * Note         :
231:                  *******************************************************************/
232:                  #define SETUP_DIRECT_KEY(AddrDirectKey,DirectKeyChannelNumber) \
233:                            mTouchCapAPI_SetUpChannelDirectKey((AddrDirectKey), \
234:                                                               (DirectKeyChannelNumber), \
235:                                                               DEFAULT_TRIP_VALUE, \
236:                                                               DEFAULT_DECODE_METHOD, \
237:                                                               DEFAULT_FILTER_METHOD);
238:                  void mTouchCapApp_DirectKeys_Create(void)
239:                  {
9D001F6C  27BDFFE0   ADDIU SP, SP, -32
9D001F70  AFB00018   SW S0, 24(SP)
9D001F88  AFBF001C   SW RA, 28(SP)
240:                      SETUP_DIRECT_KEY(&DirectKey1,DIRECTKEY1_CHANNEL);
9D001F74  27840024   ADDIU A0, GP, 36
9D001F78  24100004   ADDIU S0, ZERO, 4
9D001F7C  24050002   ADDIU A1, ZERO, 2
9D001F80  24060064   ADDIU A2, ZERO, 100
9D001F84  00003821   ADDU A3, ZERO, ZERO
9D001F8C  0F40054D   JAL mTouchCapAPI_SetUpChannelDirectKey
9D001F90  AFB00010   SW S0, 16(SP)
241:                      SETUP_DIRECT_KEY(&DirectKey2,DIRECTKEY2_CHANNEL);
9D001F94  27840014   ADDIU A0, GP, 20
9D001F98  24050003   ADDIU A1, ZERO, 3
9D001F9C  24060064   ADDIU A2, ZERO, 100
9D001FA0  00003821   ADDU A3, ZERO, ZERO
9D001FA4  0F40054D   JAL mTouchCapAPI_SetUpChannelDirectKey
9D001FA8  AFB00010   SW S0, 16(SP)
242:                      SETUP_DIRECT_KEY(&DirectKey3,DIRECTKEY3_CHANNEL);
9D001FAC  2784001C   ADDIU A0, GP, 28
9D001FB0  24050004   ADDIU A1, ZERO, 4
9D001FB4  24060064   ADDIU A2, ZERO, 100
9D001FB8  00003821   ADDU A3, ZERO, ZERO
9D001FBC  0F40054D   JAL mTouchCapAPI_SetUpChannelDirectKey
9D001FC0  AFB00010   SW S0, 16(SP)
243:                      SETUP_DIRECT_KEY(&DirectKey4,DIRECTKEY4_CHANNEL);
9D001FC4  2784002C   ADDIU A0, GP, 44
9D001FC8  24050005   ADDIU A1, ZERO, 5
9D001FCC  24060064   ADDIU A2, ZERO, 100
9D001FD0  00003821   ADDU A3, ZERO, ZERO
9D001FD4  0F40054D   JAL mTouchCapAPI_SetUpChannelDirectKey
9D001FD8  AFB00010   SW S0, 16(SP)
244:                 #if !defined( PIC32MX220_STARTER_KIT_BOARD )
245:                      SETUP_DIRECT_KEY(&DirectKey5,DIRECTKEY5_CHANNEL);
246:                 #if !defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
247:                      SETUP_DIRECT_KEY(&DirectKey6,DIRECTKEY6_CHANNEL);
248:                      SETUP_DIRECT_KEY(&DirectKey7,DIRECTKEY7_CHANNEL);
249:                      SETUP_DIRECT_KEY(&DirectKey8,DIRECTKEY8_CHANNEL);
250:                 #endif//!defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
251:                 #endif//!defined( PIC32MX220_STARTER_KIT_BOARD )
252:                 }
9D001FDC  8FBF001C   LW RA, 28(SP)
9D001FE0  8FB00018   LW S0, 24(SP)
9D001FE4  03E00008   JR RA
9D001FE8  27BD0020   ADDIU SP, SP, 32
253:                 
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/mTouchCapLib/mTouchCapAPI.c  ---------------------------
1:                   /******************************************************************************
2:                   * File Name:       mTouchCap_CvdAPI.c
3:                   * Includes:
4:                   *   void mTouchCapAPI_Init(void)
5:                   *   void mTouchCapAPI_SetUp_Default(WORD ChannelNum)
6:                   *   void mTouchCapAPI_SetUpChannelDirectKey(DIRECTKEY *Button,
7:                   *                                           BYTE Channel_number,
8:                   *                                           WORD Trip_Value,
9:                   *                                           WORD Decode_Method,
10:                  *                                           WORD Filter_Method)
11:                  *   BYTE mTouchCapAPI_GetStatusMatrixButton(MATRIXKEY *Button)
12:                  *   void mTouchCapAPI_SetUpChannelSlider4Ch(SLIDER4CH *Slider,
13:                  *                                           BYTE Slider_Channel1_Number,
14:                  *                                           BYTE Slider_Channel2_Number,
15:                  *                                           BYTE Slider_Channel3_Number,
16:                  *                                           BYTE Slider_Channel4_Number,
17:                  *                                           WORD Trip_Value,
18:                  *                                           BYTE Decode_Method,
19:                  *                                           BYTE Filter_Method)
20:                  *   SHORT mTouchCapAPI_GetStatusSlider4Ch (SLIDER4CH *Slider)
21:                  *   static void LoadChannelNumber (BYTE Channel_Number_Passed)
22:                  *   BYTE mTouchCapAPI_GetChannelTouchStatus(WORD ChIndex, BYTE Decode_Method)
23:                  *
24:                  * Dependencies:    None
25:                  * Processor:       PIC32MX795F512H
26:                  * Compiler:        C32
27:                  * Company:         Microchip Technology, Inc.
28:                  * Software License Agreement
29:                  *
30:                  * Copyright © 2011 Microchip Technology Inc.
31:                  * Microchip licenses this software to you solely for use with Microchip
32:                  * products, according to the terms of the accompanying click-wrap software
33:                  * license. Microchip and its licensors retain all right, title and interest in
34:                  * and to the software.  All rights reserved. This software and any accompanying
35:                  * information is for suggestion only. It shall not be deemed to modify
36:                  * Microchip?s standard warranty for its products.  It is your responsibility to
37:                  * ensure that this software meets your requirements.
38:                  *
39:                  * SOFTWARE IS PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
40:                  * IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
41:                  * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL
42:                  * MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY DIRECT OR INDIRECT DAMAGES OR
43:                  * EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
44:                  * OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  * SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, OR ANY CLAIMS BY THIRD PARTIES
46:                  * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *
48:                  * The aggregate and cumulative liability of Microchip and its licensors for
49:                  * damages related to the use of the software will in no event exceed $1000 or
50:                  * the amount you paid Microchip for the software, whichever is greater.
51:                  *
52:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
53:                  * TERMS AND THE TERMS OF THE ACCOMPANYING CLICK-WRAP SOFTWARE LICENSE.
54:                  *
55:                  * Change History:
56:                  * Author          Date    Comments
57:                  *------------------------------------------------------------------------------
58:                  * BDB          26-Jun-2008 First release
59:                  * SB           22-Oct-2008
60:                  * NK           24-Apr-2009 Porting for 18F46J50 Eval Board
61:                  * MC           22-Jan-2010 Porting for PIC32MX795F512H
62:                  * MWM             Mar-2011 Reogranized code, added more comments, Added decode
63:                  *                          method to mTouchCapAPI_GetChannelTouchStatus
64:                  ******************************************************************************/
65:                  
66:                  ///////////////////////////////////////////////////////////////////////////////
67:                  //  Includes
68:                  ///////////////////////////////////////////////////////////////////////////////
69:                  #include "..\mTouchConfig.h"
70:                  #include "GenericTypeDefs.h"
71:                  #include "mTouchCapAPI.h"
72:                  #include "mTouchCapPhy.h"
73:                  #include "mTouchCapTmr.h"
74:                  
75:                  /* Variables only used locally ***********************************************/
76:                  static UINT16 pressedCount[MAX_ADC_CHANNELS];  //Storage for count of pressed value for each channel
77:                  static UINT16 unpressedCount[MAX_ADC_CHANNELS];//Storage for count of unpressed value for each channel
78:                  
79:                  /* Global variables referenced elsewhere *************************************/
80:                  UINT8  Decode_Method_Used = DECODE_METHOD_MOST_PRESSED;
81:                  UINT16 ScanChannels[MAX_ADC_CHANNELS]={0xFF,0xFF,0xFF,0xFF,
82:                                                         0xFF,0xFF,0xFF,0xFF,
83:                                                         0xFF,0xFF,0xFF,0xFF,
84:                                                         0xFF};
85:                  UINT16 tripValue[MAX_ADC_CHANNELS];
86:                  UINT16 hystValue[MAX_ADC_CHANNELS];
87:                  UINT16 averageData[MAX_ADC_CHANNELS];   // running average of CVD channels
88:                  
89:                  UINT8  NumberScanChannels = 0; // store the index of the channels that has to be scanned
90:                  UINT8  button_set_number = 0; //# of current button in scan
91:                  UINT8  HF_Read_Number    = 0; //# of High Frequency reads so far,= 0,1 ... NUM_HF_READS - 1
92:                  
93:                  UINT8 volatile EmTouchDataReady;        //global indicating the reading of all channels finished
94:                  
95:                  /* External References ********************************************************/
96:                  // From mTouchCapPhy.c
97:                  extern UINT16 CurFiltdData[MAX_ADC_CHANNELS];  // current filtered value for all channels
98:                  extern UINT8  chFilterType[MAX_ADC_CHANNELS];  // Channel filter type for all channels
99:                  extern UINT16 ButtonWeight[MAX_ADC_CHANNELS]; // measurement of button presses
100:                 extern UINT16 MinButtonWeight;
101:                 extern INT8   iScanChanMinWeight;
102:                 
103:                 static void LoadChannelNumber (BYTE Channel_Number_Passed);
104:                 
105:                 /******************************************************************************
106:                  * Function:       void mTouchCapAPI_Init(void)
107:                  *
108:                  * PreCondition:    None
109:                  *
110:                  * Input:           None
111:                  *
112:                  * Output:          None
113:                  *
114:                  * Side Effects:    None
115:                  *
116:                  * Overview:        This function is used to initialize the default
117:                  *                  settings of ADC and other related modules.
118:                  *
119:                  * Note:            None
120:                  *****************************************************************************/
121:                 void mTouchCapAPI_Init(void)
122:                 {
9D0014E8  27BDFFE8   ADDIU SP, SP, -24
9D0014EC  AFBF0014   SW RA, 20(SP)
123:                     WORD Index=0;
124:                 
125:                     // init main ports, ADC ...
126:                     mTouchCapPhy_Initialize();
9D0014F0  0F40051B   JAL mTouchCapPhy_Initialize
9D0014F4  AFB00010   SW S0, 16(SP)
127:                 
128:                     //initialize the Timer4
129:                     mTouchCapPhy_TickInit();
9D0014F8  0F400519   JAL mTouchCapPhy_TickInit
9D0014FC  00008021   ADDU S0, ZERO, ZERO
130:                 
131:                     /***************************************************************************
132:                     --------------- Demo of API "mTouchCapAPI_SetUp_Defaul" -----------------------
133:                     Initialize the ADC module to defaults using the API "mTouchCapAPI_SetUp_Defaul".
134:                     ***************************************************************************/
135:                     for (Index=0; Index < NumberScanChannels; Index++)
9D001500  0B400546   J 0x9D001518
9D001504  93820001   LBU V0, 1(GP)
9D001510  3210FFFF   ANDI S0, S0, -1
9D001514  93820001   LBU V0, 1(GP)
9D001518  0202102B   SLTU V0, S0, V0
9D00151C  1440FFFA   BNE V0, ZERO, 0x9D001508
9D001520  02002021   ADDU A0, S0, ZERO
136:                     {
137:                         mTouchCapAPI_SetUp_Default(Index);
9D001508  0F400529   JAL mTouchCapAPI_SetUp_Default
9D00150C  26100001   ADDIU S0, S0, 1
138:                     }
139:                 
140:                     mTouchCapPhy_StablizeChannelData();
9D00152C  0B4004D1   J mTouchCapPhy_StablizeChannelData
9D001530  27BD0018   ADDIU SP, SP, 24
141:                 
142:                 }
9D001524  8FBF0014   LW RA, 20(SP)
9D001528  8FB00010   LW S0, 16(SP)
143:                 
144:                 
145:                 /******************************************************************************
146:                  * Function:        mTouchCapAPI_SetUp_Default(WORD ChannelNum)
147:                  *
148:                  * PreCondition:    None
149:                  *
150:                  * Input:           Channel Number
151:                  *
152:                  * Output:          None
153:                  *
154:                  * Side Effects:    None
155:                  *
156:                  * Overview:        Performs Initializations for internal variables.
157:                  *
158:                  * Note:            None
159:                  *****************************************************************************/
160:                 void mTouchCapAPI_SetUp_Default(WORD ChannelNum)
161:                 {
9D0014A4  3084FFFF   ANDI A0, A0, -1
162:                     CurFiltdData[ChannelNum]  = 32767;  // init to zero the current raw data
9D0014A8  3C03A000   LUI V1, -24576
9D0014AC  00042040   SLL A0, A0, 1
9D0014B0  24630090   ADDIU V1, V1, 144
9D0014B4  00831821   ADDU V1, A0, V1
9D0014B8  24027FFF   ADDIU V0, ZERO, 32767
9D0014BC  A4620000   SH V0, 0(V1)
163:                     averageData[ChannelNum] = 32767; // init to zero the average data value
9D0014C0  3C03A000   LUI V1, -24576
9D0014C4  24630058   ADDIU V1, V1, 88
9D0014C8  00831821   ADDU V1, A0, V1
9D0014CC  A4620000   SH V0, 0(V1)
164:                     tripValue[ChannelNum] = DEFAULT_TRIP_VALUE;  //default trip value for all the channels
9D0014D0  3C02A000   LUI V0, -24576
9D0014D4  2442003C   ADDIU V0, V0, 60
9D0014D8  00822021   ADDU A0, A0, V0
9D0014DC  24020064   ADDIU V0, ZERO, 100
165:                 }
9D0014E0  03E00008   JR RA
9D0014E4  A4820000   SH V0, 0(A0)
166:                 
167:                 
168:                 /********************************************************************
169:                 * Function: BYTE mTouchCapAPI_SetUpChannelDirectKey(DIRECTKEY *Button,
170:                 *                                                   CHAR Channel_number,
171:                 *                                                   WORD Trip_Value,
172:                 *                                                   WORD Decode_Method,
173:                 *                                                   WORD Filter_Method)
174:                 *
175:                 * PreCondition: None
176:                 *
177:                 * Input:           Button : Object of the Direct key structure
178:                 *                  Channel number : channel number of the object Button
179:                 *                                   associated with corresponding direct key.
180:                 *                  Trip Value: Default Trip value for the channel specified
181:                 *                              by the channel number.
182:                 *                  Filter_Method: The filter method associated with the Direct Key.
183:                 *                      FILTER_METHOD_SLOWAVERAGE=0,
184:                 *                      FILTER_METHOD_GATEDAVERAGE,
185:                 *                      FILTER_METHOD_FASTAVERAGE
186:                 *
187:                 *                  Decode_Method : The Decode method associated with the Direct Key.
188:                 *                      DECODE_METHOD_MOST_PRESSED,
189:                 *                      DECODE_METHOD_MULTIPLE_PRESS,
190:                 *                      DECODE_METHOD_PRESS_AND_RELEASE,
191:                 *                      DECODE_METHOD_PRESS_ASSERT
192:                 *
193:                 * Output:          SetUpStatus - Status of the Direct key(TRUE or FALSE).
194:                 *
195:                 * Side Effects :    None
196:                 *
197:                 * Overview:    This API will setup the channel associated with the Direct key .
198:                 *              The channel number, filter type and decode method are stored in
199:                 *              the structure associated with the Direct Key.
200:                 *
201:                 * Note         :
202:                 *******************************************************************/
203:                 #if defined( USE_DIRECT_KEYS ) | defined ( USE_SLIDER_2CHNL )
204:                 void mTouchCapAPI_SetUpChannelDirectKey(DIRECTKEY *Button,
205:                                                         BYTE Channel_number,
206:                                                         WORD Trip_Value,
207:                                                         WORD Decode_Method,
208:                                                         WORD Filter_Method)
209:                 {
9D001534  97A20010   LHU V0, 16(SP)
9D00153C  30A500FF   ANDI A1, A1, 255
210:                     Button->Channel_Num = Channel_number;  // Stores Channel Number
9D001550  A0850000   SB A1, 0(A0)
211:                     Button->FilterType = Filter_Method;
9D001544  304200FF   ANDI V0, V0, 255
9D00154C  A0820006   SB V0, 6(A0)
212:                     chFilterType[Channel_number] = Filter_Method;
9D001538  3C03A000   LUI V1, -24576
9D001540  246300AC   ADDIU V1, V1, 172
9D001548  00A31821   ADDU V1, A1, V1
9D001558  A0620000   SB V0, 0(V1)
213:                     Button->DecodeMethod = Decode_Method;
9D00155C  A0870007   SB A3, 7(A0)
214:                 
215:                     LoadChannelNumber(Channel_number);
216:                 }
217:                 #endif//defined( USE_DIRECT_KEYS )
218:                 
219:                 /********************************************************************
220:                 * Function: BYTE mTouchCapAPI_SetUpChannelMatrixKey(MATRIXKEY *Button,
221:                 *                                                   BYTE Row_Channel_number,
222:                 *                                                   BYTE Col_Channel_number,
223:                 *                                                   WORD Trip_Value,
224:                 *                                                   WORD Decode_Method,
225:                 *                                                   WORD Filter_Method)
226:                 *
227:                 * PreCondition :   None
228:                 *
229:                 * Input        :   Button - Object of the Matrix key structure
230:                 *                  Row_Channel_number - channel number of the Row associated with corresponding matrix key.
231:                 *                  Col_Channel_number - channel number of the Column associated with corresponding matrix key.
232:                 *                  Trip Value - Default trip value for the channel associated with corresponding matrix key
233:                 *                  Filter_Method - The filter method associated with the corresponding Matrix key
234:                 *                  Decode_Method - The Decode method associated with the corresponding Matrix key
235:                 *
236:                 * Output       :   SetUpStatus - Status of the Matrix key(TRUE or FALSE).
237:                 *
238:                 * Side Effects :   None
239:                 *
240:                 * Overview     :   This API will setup the channels of the Row and Column associated with the Matrix key.
241:                 *                  The channel number of the Row and Column, filter type and decode method are stored in the structure associated with
242:                 *                  the corresponding channel.
243:                 *
244:                 *
245:                 * Note         :
246:                 *******************************************************************/
247:                 #if defined( USE_MATRIX_KEYS )
248:                 void mTouchCapAPI_SetUpChannelMatrixKey(MATRIXKEY *Button,
249:                                                         BYTE Row_Channel_Number,
250:                                                         BYTE Col_Channel_Number,
251:                                                         WORD Trip_Value,
252:                                                         WORD Decode_Method,
253:                                                         WORD Filter_Method)
254:                 {
255:                     Button->Channel_Num[0] = Row_Channel_Number;  // Stores Channel Number of the Row associated with the Matrix key
256:                     Button->Channel_Num[1] = Col_Channel_Number;  // Stores Channel Number of the Column asscoiated with the Matrix key
257:                 
258:                     Button->FilterType = Filter_Method;   //Store the Filter type which will be common for both the multiplexed channel(Row and col)
259:                     chFilterType [Row_Channel_Number] = Filter_Method;
260:                     chFilterType [Col_Channel_Number] = Filter_Method;
261:                     Button->DecodeMethod = Decode_Method; //Store the Decode method which will be common for both the multiplexed channel(Row and col)
262:                 
263:                     //store the channels numbers in the global array for all the Matrix Key channels
264:                 
265:                     //Store the Row and column channel numbers in the global array which will be used by the ISR
266:                     // for reading the ADC value associated with the channels which are multiplxed to form a single key
267:                     LoadChannelNumber(Row_Channel_Number); LoadChannelNumber(Col_Channel_Number);
268:                 }
269:                 #endif//defined( USE_MATRIX_KEYS )
270:                 
271:                 /********************************************************************
272:                 * Function:    BYTE mTouchCapAPI_GetStatusMatrixButton (MATRIXKEY *Button)
273:                 *
274:                 * PreCondition: The Channels of the Row and Column associatd with the Matrix
275:                 *               key should have been already set up
276:                 *
277:                 * Input:     Button - Object of the Structure associated with the Matrix Key
278:                 *
279:                 * Output:    The Touch Status of the particular key.
280:                 *               0 = KEY_NOT_PRESSED
281:                 *               1 = KEY_PRESSED
282:                 *
283:                 * Side Effects:    None
284:                 *
285:                 * Overview:    This API will provide the status of the Matrix key passed which
286:                 *              will be used by the application to perform the related task.
287:                 *
288:                 * Note         :
289:                 *******************************************************************/
290:                 #if defined( USE_MATRIX_KEYS )
291:                 BYTE mTouchCapAPI_GetStatusMatrixButton (MATRIXKEY *Button)
292:                 {
293:                     BYTE MatrixKey_Status = KEY_NOT_PRESSED;
294:                     BYTE RowFlag = KEY_NOT_PRESSED;
295:                     BYTE ColFlag = KEY_NOT_PRESSED;
296:                 
297:                     /* Check if the channel used as Row for corresponding Matrix key is pressed */
298:                     //Now check to see if the requested row is pressed
299:                 
300:                     if( KEY_PRESSED == mTouchCapAPI_GetChannelTouchStatus((Button->Channel_Num[0]),(Button->DecodeMethod) ))
301:                     {
302:                         RowFlag=KEY_PRESSED;    // Used for determining ROW match
303:                     }
304:                     else
305:                     {
306:                         //Channel requested is not detected as pressed.
307:                         RowFlag= KEY_NOT_PRESSED;
308:                     }
309:                 
310:                     //Now check to see if the channel used as column for corresponding Matrix key is pressed
311:                     if( KEY_PRESSED == mTouchCapAPI_GetChannelTouchStatus((Button->Channel_Num[1]),(Button->DecodeMethod) ))
312:                     {
313:                          ColFlag=KEY_PRESSED;   // Used for determining COL match
314:                     }
315:                     else
316:                     {
317:                         //Channel requested is not detected as pressed.
318:                         ColFlag= KEY_NOT_PRESSED;
319:                     }
320:                 
321:                     // check if both the row and column corresponding to the matrix key is pressed
322:                 
323:                 
324:                     if( (ColFlag == KEY_PRESSED) && (RowFlag == KEY_PRESSED) )
325:                     {
326:                         MatrixKey_Status= KEY_PRESSED;      //matrix key is pressed
327:                     }
328:                     else
329:                     {
330:                         //If both channels are not pressed, the key is not pressed
331:                         MatrixKey_Status= KEY_NOT_PRESSED; //key is not pressed
332:                     }
333:                 
334:                     return MatrixKey_Status;
335:                 }
336:                 
337:                 #endif//defined( USE_MATRIX_KEYS )
338:                 
339:                 
340:                 /******************************************************************************
341:                 * Function: BYTE mTouchCapAPI_SetUpChannelSlider4Ch(Slider4Ch *Slider,
342:                 *                                                   BYTE Slider_Channel1_Number,
343:                 *                                                   BYTE Slider_Channel2_Number,
344:                 *                                                   BYTE Slider_Channel3_Number,
345:                 *                                                   BYTE Slider_Channel4_Number,
346:                 *                                                   WORD Trip_Value,
347:                 *                                                   BYTE Decode_Method,
348:                 *                                                   BYTE Filter_Method)
349:                 *
350:                 * PreCondition: None
351:                 *
352:                 * Input:
353:                 *  Slider : object of the 4-channel Slider structure
354:                 *  Channel number : channel # of the object Slider associated with 4-channel slider.
355:                 *  Trip Value: Trip value for the channels associated with the 4-channel slider.
356:                 *  Filter_Method: The filter method for the 4-channel slider.
357:                 *  Decode_Method:The Decode method for the 4-channel slider.
358:                 *
359:                 * Output:   SetUpStatus - Status of the 4-channel slider(TRUE or FALSE).
360:                 *
361:                 * Side Effects :    None
362:                 *
363:                 * Overview:
364:                 *  This API will setup the 4 channels associated with the 4-channel Slider.
365:                 *  The 4 channel numbers, filter type and decode method are stored in the
366:                 *  structure associated with the corresponding 4-Channel Slider
367:                 *
368:                 * Note         :
369:                 ******************************************************************************/
370:                 #if defined(USE_SLIDER_4CHNL)
371:                 void mTouchCapAPI_SetUpChannelSlider4Ch(SLIDER4CH *Slider,
372:                                                         BYTE Slider_Channel1_Number,
373:                                                         BYTE Slider_Channel2_Number,
374:                                                         BYTE Slider_Channel3_Number,
375:                                                         BYTE Slider_Channel4_Number,
376:                                                         WORD Trip_Value,
377:                                                         BYTE Decode_Method,
378:                                                         BYTE Filter_Method)
379:                 {
380:                     Slider->Channel_Num[0] = Slider_Channel1_Number;  // Stores first Channel Number of the 4-channel slider
381:                     Slider->Channel_Num[1] = Slider_Channel2_Number;  // Stores Second Channel Number of the 4-channel slider
382:                     Slider->Channel_Num[2] = Slider_Channel3_Number;  // Stores third  Channel Number of the 4-channel slider
383:                     Slider->Channel_Num[3] = Slider_Channel4_Number;  // Stores fourth Channel Number of the 4-channel slider
384:                 
385:                     Slider->FilterType = Filter_Method;   //Store the Filter type which will be common for all the channels in the 4 channel slider
386:                 
387:                     chFilterType [Slider_Channel1_Number] = Filter_Method;
388:                     chFilterType [Slider_Channel2_Number] = Filter_Method;
389:                     chFilterType [Slider_Channel3_Number] = Filter_Method;
390:                     chFilterType [Slider_Channel4_Number] = Filter_Method;
391:                 
392:                 
393:                     Slider->DecodeMethod = Decode_Method; //Store the Decode method which will be common for all the channels in the 4 channel slider
394:                 
395:                     //store the channels numbers in the global array which are associated with the 4-channel slider
396:                 
397:                     //Store the Channel 1,Channel 2,Channel 3 and Channel4  numbers of the 4-channel slider in the global array which will be used by the ISR
398:                     // for reading the ADC value associated
399:                 
400:                     LoadChannelNumber(Slider_Channel1_Number);
401:                     LoadChannelNumber(Slider_Channel2_Number);
402:                     LoadChannelNumber(Slider_Channel3_Number);
403:                     LoadChannelNumber(Slider_Channel4_Number);
404:                 }
405:                 #endif//defined(USE_SLIDER_4CHNL)
406:                 
407:                 
408:                 /******************************************************************************
409:                   Function       :  SHORT   mTouchCapAPI_GetStatusSlider4Ch (Slider4Ch *Slider)
410:                 
411:                   PreCondition   :   4-channel Slider setup is complete
412:                 
413:                  Input           :  Slider - Object of the 4-channel slider
414:                 
415:                  Output          :  sliderLevel gives the Slider percent level of the touch.
416:                 
417:                  Side Effects    :  None
418:                 
419:                  Overview        :
420:                    This API gets the percentage level of a particular 4-channel slider passed.
421:                    The output is ratio-metrically calculated from 0% to 100% proportional to
422:                    the finger on the slider.
423:                 
424:                 
425:                  *****************************************************************************/
426:                 #if defined(USE_SLIDER_4CHNL)
427:                 #include "mTouchCapApp_FourChanSlider.h"
428:                 SHORT  mTouchCapAPI_GetStatusSlider4Ch (SLIDER4CH *Slider)
429:                 {
430:                 
431:                     SHORT SliderState;
432:                     WORD Percent_Level = 0;
433:                 
434:                     if( (KEY_PRESSED == mTouchCapAPI_GetChannelTouchStatus((Slider->Channel_Num[0]),(Slider->DecodeMethod) )) ||
435:                         (KEY_PRESSED == mTouchCapAPI_GetChannelTouchStatus((Slider->Channel_Num[1]),(Slider->DecodeMethod) )) ||
436:                         (KEY_PRESSED == mTouchCapAPI_GetChannelTouchStatus((Slider->Channel_Num[2]),(Slider->DecodeMethod) )) ||
437:                         (KEY_PRESSED == mTouchCapAPI_GetChannelTouchStatus((Slider->Channel_Num[3]),(Slider->DecodeMethod) ))
438:                       )
439:                     {
440:                         /* Use the 4ch slider algorithm to get the Slider Level */
441:                         Percent_Level = mTouchCapApp_FourChannelSlider_Logic(Slider);
442:                         SliderState = (SHORT)Percent_Level;
443:                     }
444:                     else
445:                     {
446:                         SliderState = -1; // For KEY_NOT_PRESSED
447:                     }
448:                 
449:                       return SliderState;
450:                  }
451:                 #endif // end of  #if defined(USE_SLIDER_4CHNL)
452:                 
453:                 /******************************************************************************
454:                 * Function     :    void LoadChannelNumber (BYTE Channel_Number_Passed)
455:                 *
456:                 * PreCondition :    None
457:                 *
458:                 * Input        :    Channel Number
459:                 *
460:                 * Output       :    None
461:                 *
462:                 * Side Effects :    None
463:                 *
464:                 * Overview     :
465:                 * This function will load the active Touchkey Channel number in the global
466:                 * array ScanChannels[NumberScanChannels] and will also store the total channels
467:                 * used in the application.
468:                 *
469:                 * Note         :
470:                 ******************************************************************************/
471:                 static void LoadChannelNumber (BYTE Channel_Number_Passed)
472:                 {
473:                  BYTE index;
474:                  BYTE result = FALSE;
9D001568  00001821   ADDU V1, ZERO, ZERO
475:                 
476:                     for(index = 0; index<NumberScanChannels; index++)
9D001554  3C06A000   LUI A2, -24576
9D001560  93880001   LBU T0, 1(GP)
9D001564  24C40144   ADDIU A0, A2, 324
9D00156C  00001021   ADDU V0, ZERO, ZERO
9D001578  24420001   ADDIU V0, V0, 1
9D00157C  304200FF   ANDI V0, V0, 255
9D001588  24840002   ADDIU A0, A0, 2
9D00158C  5448FFFA   BNEL V0, T0, 0x9D001578
9D001590  94890000   LHU T1, 0(A0)
477:                     {
478:                        if(ScanChannels[index] == Channel_Number_Passed)
479:                        {
480:                          result = TRUE;
9D001570  0B400563   J 0x9D00158C
9D001574  24070001   ADDIU A3, ZERO, 1
9D001580  01254826   XOR T1, T1, A1
9D001584  00E9180A   MOVZ V1, A3, T1
481:                        }
482:                     }
483:                 
484:                     if(!result)
9D001594  1460000C   BNE V1, ZERO, 0x9D0015C8
9D001598  24420001   ADDIU V0, V0, 1
485:                     {
486:                         NumberScanChannels++;
487:                         NumberScanChannels = NumberScanChannels < MAX_ADC_CHANNELS ? NumberScanChannels : MAX_ADC_CHANNELS;
9D00159C  304300FF   ANDI V1, V0, 255
9D0015A0  2C63000E   SLTIU V1, V1, 14
9D0015A4  50600001   BEQL V1, ZERO, 0x9D0015AC
9D0015A8  2402000D   ADDIU V0, ZERO, 13
9D0015AC  304300FF   ANDI V1, V0, 255
9D0015B0  A3820001   SB V0, 1(GP)
488:                         ScanChannels[NumberScanChannels-1] = Channel_Number_Passed;
9D0015B4  2462FFFF   ADDIU V0, V1, -1
9D0015B8  00021040   SLL V0, V0, 1
9D0015BC  24C60144   ADDIU A2, A2, 324
9D0015C0  00463021   ADDU A2, V0, A2
9D0015C4  A4C50000   SH A1, 0(A2)
9D0015C8  03E00008   JR RA
9D0015CC  00000000   NOP
489:                     }
490:                 
491:                 }
492:                 
493:                 
494:                 /******************************************************************************
495:                 * Function: BYTE mTouchCapAPI_GetChannelTouchStatus(WORD ChIndex,
496:                 *                                                   BYTE Decode_Method)
497:                 *
498:                 * PreCondition:    None
499:                 *
500:                 * Input:    ChIndex -The Channel number.
501:                 *           Decode_Method-The type of Decode Method associated with that channel
502:                 *             DECODE_METHOD_MOST_PRESSED,
503:                 *             ECODE_METHOD_MULTIPLE_PRESS,
504:                 *             ECODE_METHOD_PRESS_AND_RELEASE,
505:                 *             ECODE_METHOD_PRESS_ASSERT
506:                 *
507:                 * Output: TouchStatus-Whether the key associated with the Channel is pressed or not
508:                 *           KEY_NOT_PRESSED,
509:                 *           KEY_PRESSED
510:                 *
511:                 * Side Effects: None
512:                 *
513:                 * Overview :
514:                 *  This API will determine if the channel which is associated with a particular
515:                 *  key is touched or not. It will output the pressed or unpressed status of the
516:                 *  channel based on the decode method which is associated with the channel.
517:                 *
518:                 * Note             :
519:                 ******************************************************************************/
520:                 BYTE mTouchCapAPI_GetChannelTouchStatus(WORD ChIndex, BYTE Decode_Method)
521:                 {
9D0015D0  3084FFFF   ANDI A0, A0, -1
9D0015D8  30A500FF   ANDI A1, A1, 255
522:                     BYTE TouchStatus = KEY_NOT_PRESSED;
523:                 
524:                     /* Check for valid channel number being passed */
525:                     if (ChIndex < MAX_ADC_CHANNELS )
9D0015D4  2C83000D   SLTIU V1, A0, 13
9D0015DC  10600089   BEQ V1, ZERO, 0x9D001804
9D0015E0  00001021   ADDU V0, ZERO, ZERO
526:                     {
527:                         switch (Decode_Method)
9D0015E4  10A00006   BEQ A1, ZERO, 0x9D001600
9D0015E8  3C07A000   LUI A3, -24576
9D0015EC  2CA50003   SLTIU A1, A1, 3
9D0015F0  10A00084   BEQ A1, ZERO, 0x9D001804
9D0015F4  00041840   SLL V1, A0, 1
9D0015F8  0B4005BE   J 0x9D0016F8
9D0015FC  00000000   NOP
528:                         {
529:                             case DECODE_METHOD_MOST_PRESSED:
530:                 
531:                                 if (CurFiltdData[ChIndex] < (averageData[ChIndex] - tripValue[ChIndex]))
9D001600  00041840   SLL V1, A0, 1
9D001604  24E50090   ADDIU A1, A3, 144
9D001608  00652821   ADDU A1, V1, A1
9D00160C  3C06A000   LUI A2, -24576
9D001610  94A80000   LHU T0, 0(A1)
9D001614  24C50058   ADDIU A1, A2, 88
9D001618  00652821   ADDU A1, V1, A1
9D00161C  94AA0000   LHU T2, 0(A1)
9D001620  3C05A000   LUI A1, -24576
9D001624  24A9003C   ADDIU T1, A1, 60
9D001628  00694821   ADDU T1, V1, T1
9D00162C  95290000   LHU T1, 0(T1)
9D001630  01495023   SUBU T2, T2, T1
9D001634  010A502A   SLT T2, T0, T2
9D001638  00C04821   ADDU T1, A2, ZERO
9D00163C  00A04021   ADDU T0, A1, ZERO
9D001640  11400013   BEQ T2, ZERO, 0x9D001690
9D001644  3C05A000   LUI A1, -24576
532:                                 {
533:                                     unpressedCount[ChIndex] = 0;
9D001648  3C06A000   LUI A2, -24576
9D00164C  24C6010C   ADDIU A2, A2, 268
9D001654  00663021   ADDU A2, V1, A2
9D00165C  A4C00000   SH ZERO, 0(A2)
534:                                     pressedCount[ChIndex] += 1;
9D001650  24A50128   ADDIU A1, A1, 296
9D001658  00651821   ADDU V1, V1, A1
9D001660  94660000   LHU A2, 0(V1)
9D001664  24C60001   ADDIU A2, A2, 1
9D001668  30C6FFFF   ANDI A2, A2, -1
9D00166C  A4660000   SH A2, 0(V1)
535:                                     // Single-Button Only (Lockout other keys option)
536:                                     if(pressedCount[ChIndex] > DEBOUNCECOUNT)
9D001670  2CC60004   SLTIU A2, A2, 4
9D001674  14C0000A   BNE A2, ZERO, 0x9D0016A0
9D001678  3C05A000   LUI A1, -24576
537:                                     {
538:                                         Decode_Method_Used=DECODE_METHOD_MOST_PRESSED;
9D001680  A3800000   SB ZERO, 0(GP)
539:                                         TouchStatus = ChIndex == iScanChanMinWeight ? KEY_PRESSED : KEY_NOT_PRESSED;
9D00167C  83820036   LB V0, 54(GP)
9D001684  00821026   XOR V0, A0, V0
9D001688  0B4005A8   J 0x9D0016A0
9D00168C  2C420001   SLTIU V0, V0, 1
540:                                     }
541:                                 }
542:                                 else
543:                                 {
544:                                     pressedCount[ChIndex] = 0;
9D001690  24A50128   ADDIU A1, A1, 296
9D001694  00651821   ADDU V1, V1, A1
9D001698  A4600000   SH ZERO, 0(V1)
545:                                     TouchStatus = KEY_NOT_PRESSED;
546:                                 }
547:                 
548:                                 if (CurFiltdData[ChIndex] > (averageData[ChIndex] - tripValue[ChIndex] + hystValue[ChIndex]))
9D00169C  3C05A000   LUI A1, -24576
9D0016A0  00042040   SLL A0, A0, 1
9D0016A4  24E70090   ADDIU A3, A3, 144
9D0016A8  24A50074   ADDIU A1, A1, 116
9D0016AC  25260058   ADDIU A2, T1, 88
9D0016B0  00873821   ADDU A3, A0, A3
9D0016B4  00852821   ADDU A1, A0, A1
9D0016B8  00863021   ADDU A2, A0, A2
9D0016BC  94E30000   LHU V1, 0(A3)
9D0016C0  94A70000   LHU A3, 0(A1)
9D0016C4  94C50000   LHU A1, 0(A2)
9D0016C8  00E53821   ADDU A3, A3, A1
9D0016CC  2505003C   ADDIU A1, T0, 60
9D0016D0  00852821   ADDU A1, A0, A1
9D0016D4  94A60000   LHU A2, 0(A1)
9D0016D8  00E62823   SUBU A1, A3, A2
9D0016DC  00A3282A   SLT A1, A1, V1
9D0016E0  3C03A000   LUI V1, -24576
9D0016E4  14A0003D   BNE A1, ZERO, 0x9D0017DC
9D0016E8  2463010C   ADDIU V1, V1, 268
549:                                 {   // Is scaledBigValue above { average - (trip + hysteresis) } ? .. Yes
550:                                     // Button is up.
551:                                     unpressedCount[ChIndex] += 1;
552:                                     if (unpressedCount[ChIndex] > DEBOUNCECOUNT)
553:                                     {
554:                                         TouchStatus = KEY_NOT_PRESSED;
555:                                     }
556:                                 }
557:                                 else
558:                                 {
559:                                     unpressedCount[ChIndex] = 0;
9D0016EC  00642021   ADDU A0, V1, A0
9D0016F0  03E00008   JR RA
9D0016F4  A4800000   SH ZERO, 0(A0)
560:                                 }
561:                 
562:                                 break;
563:                 
564:                 
565:                             case DECODE_METHOD_MULTIPLE_PRESS:
566:                             case DECODE_METHOD_PRESS_ASSERT:
567:                                 if (CurFiltdData[ChIndex] < (averageData[ChIndex] - tripValue[ChIndex]))
9D0016F8  24E50090   ADDIU A1, A3, 144
9D0016FC  00652821   ADDU A1, V1, A1
9D001700  3C06A000   LUI A2, -24576
9D001704  94A80000   LHU T0, 0(A1)
9D001708  24C50058   ADDIU A1, A2, 88
9D00170C  00652821   ADDU A1, V1, A1
9D001710  94AA0000   LHU T2, 0(A1)
9D001714  3C05A000   LUI A1, -24576
9D001718  24A9003C   ADDIU T1, A1, 60
9D00171C  00694821   ADDU T1, V1, T1
9D001720  95290000   LHU T1, 0(T1)
9D001724  01495023   SUBU T2, T2, T1
9D001728  010A502A   SLT T2, T0, T2
9D00172C  00C04821   ADDU T1, A2, ZERO
9D001730  00A04021   ADDU T0, A1, ZERO
9D001734  11400012   BEQ T2, ZERO, 0x9D001780
9D001738  3C05A000   LUI A1, -24576
568:                                 {
569:                                     unpressedCount[ChIndex] = 0;
9D00173C  3C06A000   LUI A2, -24576
9D001740  24C6010C   ADDIU A2, A2, 268
9D001748  00663021   ADDU A2, V1, A2
9D001750  A4C00000   SH ZERO, 0(A2)
570:                                     pressedCount[ChIndex] += 1;
9D001744  24A50128   ADDIU A1, A1, 296
9D00174C  00651821   ADDU V1, V1, A1
9D001754  94660000   LHU A2, 0(V1)
9D001758  24C60001   ADDIU A2, A2, 1
9D00175C  30C6FFFF   ANDI A2, A2, -1
9D001760  A4660000   SH A2, 0(V1)
571:                                     // Single-Button Only (Lockout other keys option)
572:                                     if(pressedCount[ChIndex] > DEBOUNCECOUNT)
9D001764  2CC60004   SLTIU A2, A2, 4
9D001768  14C00009   BNE A2, ZERO, 0x9D001790
9D00176C  3C05A000   LUI A1, -24576
573:                                     {
574:                                        TouchStatus = KEY_PRESSED;
9D001778  0B4005E4   J 0x9D001790
9D00177C  24020001   ADDIU V0, ZERO, 1
575:                                        Decode_Method_Used = DECODE_METHOD_PRESS_ASSERT;
9D001770  24020002   ADDIU V0, ZERO, 2
9D001774  A3820000   SB V0, 0(GP)
576:                                     }
577:                                 }
578:                                 else
579:                                 {
580:                                     pressedCount[ChIndex] = 0;
9D001780  24A50128   ADDIU A1, A1, 296
9D001784  00651821   ADDU V1, V1, A1
9D001788  A4600000   SH ZERO, 0(V1)
581:                                     TouchStatus = KEY_NOT_PRESSED;
582:                                 }
583:                 
584:                                 if (CurFiltdData[ChIndex] > (averageData[ChIndex] - tripValue[ChIndex] + hystValue[ChIndex]))
9D00178C  3C05A000   LUI A1, -24576
9D001790  00042040   SLL A0, A0, 1
9D001794  24E70090   ADDIU A3, A3, 144
9D001798  24A50074   ADDIU A1, A1, 116
9D00179C  25260058   ADDIU A2, T1, 88
9D0017A0  00873821   ADDU A3, A0, A3
9D0017A4  00852821   ADDU A1, A0, A1
9D0017A8  00863021   ADDU A2, A0, A2
9D0017AC  94E30000   LHU V1, 0(A3)
9D0017B0  94A70000   LHU A3, 0(A1)
9D0017B4  94C50000   LHU A1, 0(A2)
9D0017B8  00E53821   ADDU A3, A3, A1
9D0017BC  2505003C   ADDIU A1, T0, 60
9D0017C0  00852821   ADDU A1, A0, A1
9D0017C4  94A60000   LHU A2, 0(A1)
9D0017C8  00E62823   SUBU A1, A3, A2
9D0017CC  00A3282A   SLT A1, A1, V1
9D0017D0  3C03A000   LUI V1, -24576
9D0017D4  10A00009   BEQ A1, ZERO, 0x9D0017FC
9D0017D8  2463010C   ADDIU V1, V1, 268
585:                                 {       // Is scaledBigValue above { average - (trip + hysteresis) } ? .. Yes
586:                                         // Button is up.
587:                                     unpressedCount[ChIndex] = unpressedCount[ChIndex] + 1;
9D0017DC  00642021   ADDU A0, V1, A0
9D0017E0  94850000   LHU A1, 0(A0)
9D0017E4  24A50001   ADDIU A1, A1, 1
9D0017E8  30A5FFFF   ANDI A1, A1, -1
9D0017EC  A4850000   SH A1, 0(A0)
588:                                     if (unpressedCount[ChIndex] > DEBOUNCECOUNT)
9D0017F0  2CA50004   SLTIU A1, A1, 4
589:                                     {
590:                                         TouchStatus = KEY_NOT_PRESSED;
9D0017F4  03E00008   JR RA
9D0017F8  0005100A   MOVZ V0, ZERO, A1
591:                                     }
592:                 
593:                                 }
594:                                 else
595:                                 {
596:                                     unpressedCount[ChIndex] = 0;
9D0017FC  00642021   ADDU A0, V1, A0
9D001800  A4800000   SH ZERO, 0(A0)
597:                                 }
598:                 
599:                                 break;
600:                 
601:                             default:
602:                                 TouchStatus = KEY_NOT_PRESSED;
603:                                 break;
604:                 
605:                         }
606:                     }
607:                 
608:                     return TouchStatus;
609:                 }
9D001804  03E00008   JR RA
9D001808  00000000   NOP
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/mTouchCapLib/mTouchCapADC.c  ---------------------------
1:                   /******************************************************************************
2:                   * File Name:       mTouchCapAdc.c
3:                   * Includes:
4:                   *   void mTouchCapADC_InitADC(void )
5:                   *
6:                   * Dependencies:    None
7:                   * Processor:       PIC32MX795F512H
8:                   * Compiler:        C32
9:                   * Company:         Microchip Technology, Inc.
10:                  * Software License Agreement
11:                  *
12:                  * Copyright © 2011 Microchip Technology Inc.
13:                  * Microchip licenses this software to you solely for use with Microchip
14:                  * products, according to the terms of the accompanying click-wrap software
15:                  * license. Microchip and its licensors retain all right, title and interest in
16:                  * and to the software.  All rights reserved. This software and any accompanying
17:                  * information is for suggestion only. It shall not be deemed to modify
18:                  * Microchip?s standard warranty for its products.  It is your responsibility to
19:                  * ensure that this software meets your requirements.
20:                  *
21:                  * SOFTWARE IS PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
22:                  * IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
23:                  * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL
24:                  * MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY DIRECT OR INDIRECT DAMAGES OR
25:                  * EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
26:                  * OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
27:                  * SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, OR ANY CLAIMS BY THIRD PARTIES
28:                  * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
29:                  *
30:                  * The aggregate and cumulative liability of Microchip and its licensors for
31:                  * damages related to the use of the software will in no event exceed $1000 or
32:                  * the amount you paid Microchip for the software, whichever is greater.
33:                  *
34:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
35:                  * TERMS AND THE TERMS OF THE ACCOMPANYING CLICK-WRAP SOFTWARE LICENSE.
36:                  *
37:                  * Author    Date          Comments
38:                  *--------------------------------------------------------------------------------
39:                  * MC        22-Jan-2010   First release of ADCDriver.c, ADCDriver.h
40:                  *                         Porting for PIC32MX795F512H
41:                  * MWM       28 Mar 2011   Removed ADC ISR, capture now in Timer 4 ISR.
42:                  ********************************************************************************/
43:                  #include "..\mTouchConfig.h"
44:                  #include "..\HardwareProfile.h"
45:                  #include "GenericTypeDefs.h"
46:                  #include "mTouchCapADC.h"
47:                  #include "mTouchCapAPI.h"
48:                  
49:                  // Definition of PortPinADC matrix, assigning Port-Pin to every ADC channel.
50:                  #if   defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
51:                        defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
52:                  
53:                  UINT16 PortPinADC[MAX_ADC_CHANNELS] = { 0xB0, 0xB1, 0xB2, 0xB3,
54:                                                          0xB4, 0xB5, 0xB6, 0xB7,
55:                                                          0xB8, 0xB9, 0xBA, 0xBB,
56:                                                          0xBC, 0xBD, 0xBE, 0xBF };
57:                  #define ADC_CHAN_SELECT AD1CHS0
58:                  #define ADC_PORT_CONFIG AD1PCFGL
59:                  
60:                  #elif defined( PIC32MC764F128_EXPLORER_16_BOARD ) || \
61:                        defined( PIC32MX795_CAP_TOUCH_EVAL_BOARD )  || \
62:                        defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
63:                  
64:                  #define ADC_CHAN_SELECT AD1CHS
65:                  #define ADC_PORT_CONFIG AD1PCFG
66:                  
67:                  UINT16 PortPinADC[MAX_ADC_CHANNELS] = { 0xB0, 0xB1, 0xB2, 0xB3,
68:                                                          0xB4, 0xB5, 0xB6, 0xB7,
69:                                                          0xB8, 0xB9, 0xBA, 0xBB,
70:                                                          0xBC, 0xBD, 0xBE, 0xBF };
71:                  
72:                  #elif defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD ) || \
73:                        defined( PIC32MX220_STARTER_KIT_BOARD )
74:                  
75:                  #define ADC_CHAN_SELECT AD1CHS
76:                  #define ADC_PORT_CONFIG AD1PCFG
77:                  
78:                  UINT16 PortPinADC[MAX_ADC_CHANNELS] = { 0xA0, 0xA1, 0xB0, 0xB1,
79:                                                          0xB2, 0xB3, 0xC0, 0xC1,
80:                                                          0xC2, 0xBF, 0xBE, 0xBD,
81:                                                          0xC3 };
82:                  
83:                  #endif
84:                  
85:                  #if defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD )   || \
86:                      defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD ) || \
87:                      defined( PIC32MC764F128_EXPLORER_16_BOARD )  || \
88:                      defined( PIC32MX795_CAP_TOUCH_EVAL_BOARD )   || \
89:                      defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
90:                  
91:                  void mTouchCapADC_InitADC(void)
92:                  {
93:                  //*****************************************************************************
94:                  // ADC Setup
95:                  //*****************************************************************************
96:                  
97:                      // configure and enable the ADC
98:                      AD1CON1 = 0x0;
99:                  #if defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD )|| \
100:                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
101:                     AD1CON1bits.AD12B = 1;
102:                 #endif//defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD )...
103:                 
104:                 
105:                     /* do not scan inputs */
106:                     /* interrupt at completion of each conversion */
107:                     /* always use MUXA */
108:                     AD1CON2 = 0x0;
109:                 
110:                 #if defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD )|| \
111:                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
112:                     /* clock derived from periph clock */
113:                     /* Tadc = (AD1CON3<7:0>+1)*Tcy */
114:                     /* Tadc = (    5       +1)*Tcy */
115:                     /* Tadc = 6 * Tcy = 6 * 12.5 ns = 75 ns > 65 ns required */
116:                     AD1CON3 = 0x0005;
117:                 #else
118:                     /* clock derived from periph clock */
119:                     /* Tadc = 2*(AD1CON3<7:0>+1)*Tpbus */
120:                     /* Tadc = 2*(    2       +1)*Tpbus */
121:                     /* Tadc = 6 * Tpbus = 6 * 12.5 ns = 75 ns > 65 ns required */
122:                     AD1CON3 = 0x0002;
123:                 #endif//defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD )...
124:                 
125:                     /* reset value for channel select at this point */
126:                     ADC_CHAN_SELECT = 0x0;
127:                 
128:                 #if  defined(USE_DIRECT_KEYS)
129:                 
130:                 # if defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
131:                  // Port configuration defined in HardwareProfile.h
132:                     ADC_PORT_CONFIG =
133:                               ~( (1<<DIRECTKEY1_CHANNEL) |
134:                                  (1<<DIRECTKEY2_CHANNEL) |
135:                                  (1<<DIRECTKEY3_CHANNEL) |
136:                                  (1<<DIRECTKEY4_CHANNEL) |
137:                                  (1<<DIRECTKEY5_CHANNEL) );
138:                 # else
139:                  // Port configuration defined in HardwareProfile.h
140:                     ADC_PORT_CONFIG =
141:                               ~( (1<<DIRECTKEY1_CHANNEL) |
142:                                  (1<<DIRECTKEY2_CHANNEL) |
143:                                  (1<<DIRECTKEY3_CHANNEL) |
144:                                  (1<<DIRECTKEY4_CHANNEL) |
145:                                  (1<<DIRECTKEY5_CHANNEL) |
146:                                  (1<<DIRECTKEY6_CHANNEL) |
147:                                  (1<<DIRECTKEY7_CHANNEL) |
148:                                  (1<<DIRECTKEY8_CHANNEL) );
149:                 # endif//defined( PIC32MX795_ONE_PIC_MICRO_DEMO_BOARD )
150:                 
151:                 #elif defined(USE_MATRIX_KEYS)
152:                 
153:                  // Port configuration defined in HardwareProfile.h
154:                     ADC_PORT_CONFIG =
155:                              ~((1<<MATRIXKEY0_ROW_CHANNEL)  | (1<<MATRIXKEY0_COLUMN_CHANNEL)  |
156:                                (1<<MATRIXKEY1_ROW_CHANNEL)  | (1<<MATRIXKEY1_COLUMN_CHANNEL)  |
157:                                (1<<MATRIXKEY2_ROW_CHANNEL)  | (1<<MATRIXKEY2_COLUMN_CHANNEL)  |
158:                                (1<<MATRIXKEY3_ROW_CHANNEL)  | (1<<MATRIXKEY3_COLUMN_CHANNEL)  |
159:                                (1<<MATRIXKEY4_ROW_CHANNEL)  | (1<<MATRIXKEY4_COLUMN_CHANNEL)  |
160:                                (1<<MATRIXKEY5_ROW_CHANNEL)  | (1<<MATRIXKEY5_COLUMN_CHANNEL)  |
161:                                (1<<MATRIXKEY6_ROW_CHANNEL)  | (1<<MATRIXKEY6_COLUMN_CHANNEL)  |
162:                                (1<<MATRIXKEY7_ROW_CHANNEL)  | (1<<MATRIXKEY7_COLUMN_CHANNEL)  |
163:                                (1<<MATRIXKEY8_ROW_CHANNEL)  | (1<<MATRIXKEY8_COLUMN_CHANNEL)  |
164:                                (1<<MATRIXKEY9_ROW_CHANNEL)  | (1<<MATRIXKEY9_COLUMN_CHANNEL)  |
165:                                (1<<MATRIXKEY10_ROW_CHANNEL) | (1<<MATRIXKEY10_COLUMN_CHANNEL) |
166:                                (1<<MATRIXKEY11_ROW_CHANNEL) | (1<<MATRIXKEY11_COLUMN_CHANNEL) );
167:                 
168:                 #elif defined(USE_SLIDER_4CHNL)
169:                 
170:                  // Port configuration defined in HardwareProfile.h
171:                     ADC_PORT_CONFIG =
172:                               ~( (1<<FOUR_CH_SLIDER1_CHANNEL0) |
173:                                  (1<<FOUR_CH_SLIDER1_CHANNEL1) |
174:                                  (1<<FOUR_CH_SLIDER1_CHANNEL2) |
175:                                  (1<<FOUR_CH_SLIDER1_CHANNEL3) );
176:                 
177:                 #elif defined( USE_SLIDER_2CHNL )
178:                 
179:                  // Port configuration defined in HardwareProfile.h
180:                     ADC_PORT_CONFIG =
181:                               ~( (1<<DIRECTKEY1_CHANNEL) |
182:                                  (1<<DIRECTKEY2_CHANNEL) );
183:                 
184:                 #else
185:                 #   error("Don't recognize demo type!")
186:                 #endif
187:                 
188:                 #if defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
189:                     defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
190:                     ADC_PORT_CONFIG &= ~(1<<REF_CHANNEL);
191:                 #endif//defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD )...
192:                 
193:                 #if   defined( PIC24HJ128_CAP_TOUCH_EVAL_BOARD ) || \
194:                       defined( DSPIC33FJ128_CAP_TOUCH_EVAL_BOARD )
195:                     /* no channel is scanned */
196:                     AD1CSSH = AD1CSSL = 0;
197:                     /* DIS-ENABLE interrupt */
198:                     IEC0bits.AD1IE = 0;
199:                 #else
200:                     /* no channel is scanned */
201:                     AD1CSSL = 0x0;
202:                     /* DIS-ENABLE interrupt */
203:                     IEC1bits.AD1IE = 0;
204:                 #endif
205:                 }
206:                 
207:                 #elif defined( PIC32MX220_CAP_TOUCH_EVAL_BOARD ) || \
208:                       defined( PIC32MX220_STARTER_KIT_BOARD )
209:                 
210:                 void mTouchCapADC_InitADC(void)
211:                 {
212:                 //*****************************************************************************
213:                 // ADC Setup
214:                 //*****************************************************************************
215:                 
216:                     // configure and enable the ADC
217:                     AD1CON1 = 0x0;
9D002320  3C02BF81   LUI V0, -16511
9D002324  AC409000   SW ZERO, -28672(V0)
218:                 
219:                     /* do not scan inputs */
220:                     /* interrupt at completion of each conversion */
221:                     /* always use MUXA */
222:                     AD1CON2 = 0x0;
9D002328  3C02BF81   LUI V0, -16511
9D00232C  AC409010   SW ZERO, -28656(V0)
223:                 
224:                     /* clock derived from periph clock */
225:                     /* Tadc = 2*(AD1CON<7:0>+1)*Tpbus */
226:                     /* Tadc = 2*(   1       +1)*Tpbus */
227:                     /* Tadc = 4 * Tpbus = 4 * 25 ns = 100 ns > 65 ns required */
228:                     AD1CON3 = 0x0001;
9D002330  24030001   ADDIU V1, ZERO, 1
9D002334  3C02BF81   LUI V0, -16511
9D002338  AC439020   SW V1, -28640(V0)
229:                 
230:                     /* reset value for channel select at this point */
231:                     AD1CHS = 0x0;
9D00233C  3C02BF81   LUI V0, -16511
9D002340  AC409040   SW ZERO, -28608(V0)
232:                 
233:                 #if defined( PIC32MX220_STARTER_KIT_BOARD )
234:                     ANSELA = 0x0000;
9D002344  3C02BF88   LUI V0, -16504
9D002348  AC406000   SW ZERO, 24576(V0)
235:                     ANSELB = 0x0000;
9D00234C  3C02BF88   LUI V0, -16504
9D002350  AC406100   SW ZERO, 24832(V0)
236:                 //    ANSELC = (1<<0) | (1<<1) | (1<<2) | (1<<3); //RC0,1,2,3
237:                 #else
238:                     ANSELA = (1<<0) | (1<<1); //RA0,1
239:                     ANSELB = (1<<2) | (1<<3) | (1<<13) | (1<<14) | (1<<15); //RB2,3,13,14,15
240:                     ANSELC = (1<<0) | (1<<1) | (1<<2) | (1<<3); //RC0,1,2,3
241:                 #endif
242:                 
243:                     /* no channel is scanned */
244:                     AD1CSSL = 0x0;
9D002354  3C02BF81   LUI V0, -16511
9D002358  AC409050   SW ZERO, -28592(V0)
245:                 
246:                     /* DIS-ENABLE interrupt */
247:                     IEC0bits.AD1IE = 0;
9D00235C  3C02BF88   LUI V0, -16504
9D002360  8C431060   LW V1, 4192(V0)
9D002364  7C03E704   INS V1, ZERO, 28, 1
9D002368  AC431060   SW V1, 4192(V0)
248:                 
249:                 }
9D00236C  03E00008   JR RA
9D002370  00000000   NOP
250:                 #endif//defined( PIC32MX220_STARTER_KIT_BOARD )
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/mTouchCapLib/TimerCallbackFunc4.c  ---------------------
1:                   /******************************************************************************
2:                   * File Name:       Timer4CallbackFunc4.c
3:                   * Includes:
4:                   *   void TimerCallbackFunc4(void)
5:                   *
6:                   * Dependencies:    None
7:                   * Processor:       PIC32MX220F032
8:                   * Compiler:        C32
9:                   * Company:         Microchip Technology, Inc.
10:                  * Software License Agreement
11:                  *
12:                  * Copyright © 2011 Microchip Technology Inc.
13:                  * Microchip licenses this software to you solely for use with Microchip
14:                  * products, according to the terms of the accompanying click-wrap software
15:                  * license. Microchip and its licensors retain all right, title and interest in
16:                  * and to the software.  All rights reserved. This software and any accompanying
17:                  * information is for suggestion only. It shall not be deemed to modify
18:                  * Microchip?s standard warranty for its products.  It is your responsibility to
19:                  * ensure that this software meets your requirements.
20:                  *
21:                  * SOFTWARE IS PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
22:                  * IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
23:                  * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL
24:                  * MICROCHIP OR ITS LICENSORS BE LIABLE FOR ANY DIRECT OR INDIRECT DAMAGES OR
25:                  * EXPENSES INCLUDING BUT NOT LIMITED TO INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
26:                  * OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
27:                  * SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, OR ANY CLAIMS BY THIRD PARTIES
28:                  * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
29:                  *
30:                  * The aggregate and cumulative liability of Microchip and its licensors for
31:                  * damages related to the use of the software will in no event exceed $1000 or
32:                  * the amount you paid Microchip for the software, whichever is greater.
33:                  *
34:                  * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
35:                  * TERMS AND THE TERMS OF THE ACCOMPANYING CLICK-WRAP SOFTWARE LICENSE.
36:                  *
37:                  *
38:                  * Author    Date    Comments
39:                  *-------------------------------------------------------------------------
40:                  * BDB    26-Jun-2008 First release
41:                  * NK     24-Apr-2009 Porting for 18F46J50 Eval Board
42:                  * MC     22-Ian-2010 First release of TMRDriver.c, TMRDriver.h
43:                  *                    Porting for PIC32MX795F512H
44:                  * MWM    06-Sep-2011 Moved Callback to separate file.
45:                  ******************************************************************************/
46:                  #include "..\mTouchConfig.h"
47:                  #include "p32xxxx.h"
48:                  
49:                  // Check that part has CTMU module
50:                  #if !defined( _CTMU_IRQ )
51:                  #   error('This part doesn''t have a CTMU module!')
52:                  #endif
53:                  
54:                  // From  mTouchCapAPI.c
55:                  extern  UINT8 HF_Read_Number;          //# of current HF scan
56:                  extern UINT16 ScanChannels[MAX_ADC_CHANNELS];
57:                  extern  UINT8 NumberScanChannels;                   // store the index of the channels that has to be scanned
58:                  extern volatile UINT8 EmTouchDataReady;      //global indicating the reading of all channels finished
59:                  extern  UINT8 button_set_number;       //# of current button in scan
60:                  
61:                  // from mTouchCapPhy.c
62:                  extern UINT32 ButtonCumulativeSum[MAX_ADC_CHANNELS]; // to compute average
63:                  #if   defined( UART_DUMP_RAW_COUNTS )
64:                  extern UINT16 CurRawData[  NUM_HF_READS][MAX_ADC_CHANNELS]; // Scratch storage for UART dump
65:                  #elif defined( UART_DUMP_ALL_COUNTS )
66:                  extern UINT16 CurRawData[3*NUM_HF_READS][MAX_ADC_CHANNELS]; // Scratch storage for UART dump
67:                  #endif
68:                  
69:                  // From mTouchCapADC.c
70:                  extern UINT16 PortPinADC[MAX_ADC_CHANNELS];
71:                  
72:                  // From mTouchCapTmr.c
73:                  extern volatile BOOL IgnoreCurrentDataFlag; // Flag set by application to signal when mTouch
74:                                                              // should ignore data being measured.
75:                  
76:                  // Locals
77:                  #if defined( __32MX220F032D__ ) || defined( __32MX250F128D__ )
78:                  static UINT16 OldRawData[MAX_ADC_CHANNELS] = { 0x7FFF, 0x7FFF, 0x7FFF, 0x7FFF,
79:                                                                 0x7FFF, 0x7FFF, 0x7FFF, 0x7FFF,
80:                                                                 0x7FFF, 0x7FFF, 0x7FFF, 0x7FFF,
81:                                                                 0x7FFF }; // raw value from previous set of ADC scans
82:                  #else
83:                  static UINT16 OldRawData[MAX_ADC_CHANNELS] = { 0x7FFF, 0x7FFF, 0x7FFF, 0x7FFF,
84:                                                                 0x7FFF, 0x7FFF, 0x7FFF, 0x7FFF,
85:                                                                 0x7FFF, 0x7FFF, 0x7FFF, 0x7FFF,
86:                                                                 0x7FFF, 0x7FFF, 0x7FFF, 0x7FFF }; // raw value from previous set of ADC scans
87:                  #endif//defined( __32MX220F032D__ ) || defined( __32MX250F128D__ )
88:                  
89:                  /*
90:                      This version of the call back function uses the CTMU module.
91:                   */
92:                  void TimerCallbackFunc4(void)
93:                  {
94:                      UINT16 Vpos, Vmeas, Vupdate;
95:                      UINT16 iChan, PortPinChan, iPort, iPin, iPinBit;
96:                  
97:                      iChan = ScanChannels[button_set_number];
9D003D38  93830002   LBU V1, 2(GP)
9D003D3C  3C02A000   LUI V0, -24576
9D003D40  24420144   ADDIU V0, V0, 324
9D003D44  00031840   SLL V1, V1, 1
9D003D48  00621021   ADDU V0, V1, V0
9D003D4C  94460000   LHU A2, 0(V0)
98:                      PortPinChan = PortPinADC[iChan];
9D003D50  3C02A000   LUI V0, -24576
9D003D54  24420198   ADDIU V0, V0, 408
9D003D58  00061840   SLL V1, A2, 1
9D003D5C  00621021   ADDU V0, V1, V0
9D003D60  94440000   LHU A0, 0(V0)
99:                      iPort   = (PortPinChan>>4) & 0x0F;
9D003D68  7C851900   EXT A1, A0, 4, 4
100:                     iPin    =  PortPinChan & 0x0F;
101:                     iPinBit = 1<<iPin;
9D003D64  24020001   ADDIU V0, ZERO, 1
9D003D6C  3084000F   ANDI A0, A0, 15
9D003D70  00822004   SLLV A0, V0, A0
9D003D7C  3084FFFF   ANDI A0, A0, -1
102:                 
103:                 //*****************************************************************************
104:                 // Measure Vpos
105:                 //*****************************************************************************
106:                     AD1CHSbits.CH0SA = iChan; // Switch ADC to sensor pin
9D003D74  3C02BF81   LUI V0, -16511
9D003D78  8C439040   LW V1, -28608(V0)
9D003D80  7CC39C04   INS V1, A2, 16, 4
9D003D84  AC439040   SW V1, -28608(V0)
107:                 
108:                     switch ( iPort )
9D003D88  2402000A   ADDIU V0, ZERO, 10
9D003D8C  10A20005   BEQ A1, V0, 0x9D003DA4
9D003D90  2402000B   ADDIU V0, ZERO, 11
9D003D94  14A20007   BNE A1, V0, 0x9D003DB4
9D003D98  3C02BF88   LUI V0, -16504
9D003D9C  0B400F6C   J 0x9D003DB0
9D003DA0  00000000   NOP
109:                     {
110:                         case 0xA:
111:                             TRISASET = iPinBit;// Sensor pin tristated, now input
9D003DA4  3C02BF88   LUI V0, -16504
9D003DA8  0B400F6D   J 0x9D003DB4
112:                             break;
9D003DAC  AC446018   SW A0, 24600(V0)
113:                         case 0xB:
114:                             TRISBSET = iPinBit;// Sensor pin tristated, now input
9D003DB0  AC446118   SW A0, 24856(V0)
115:                             break;
116:                         case 0xC:
117:                 //            TRISCSET = iPinBit;// Sensor pin tristated, now input
118:                             break;
119:                     }
120:                     ChargeDelay();
9D003DB4  00000000   NOP
9D003DB8  00000000   NOP
121:                 
122:                 
123:                 #if defined( TICKLE_LED1 )
124:                   //if ( button_set_number == 3 )
125:                 //  PMADDRSET = 1<<5;
126:                 //  LATCSET = 1<<8;           // Turn on LED1 on Pin RPC8
127:                     LATCSET = 1<<5;           // Turn on LED1 on Pin RPC5
128:                 #endif//defined( TICKLE_LED1 )
129:                     asm("di"); // Disable interrupts
9D003DBC  41606000   DI ZERO
130:                 
131:                     AD1CON1bits.SAMP = 1;     // Start ADC sampling
9D003DC0  3C03BF81   LUI V1, -16511
9D003DC4  8C629000   LW V0, -28672(V1)
9D003DC8  24060001   ADDIU A2, ZERO, 1
9D003DCC  7CC20844   INS V0, A2, 1, 1
9D003DD0  AC629000   SW V0, -28672(V1)
132:                     CTMUCONbits.IDISSEN = 1;  // Ground charge pump
9D003DD4  3C02BF81   LUI V0, -16511
9D003DD8  8C47A200   LW A3, -24064(V0)
9D003DDC  7CC74A44   INS A3, A2, 9, 1
9D003DE0  AC47A200   SW A3, -24064(V0)
133:                 
134:                     // Four ChargeDelay's seem necessary for stable behavior
135:                     ChargeDelay();            // Wait as button discharges
9D003DE4  00000000   NOP
9D003DE8  00000000   NOP
136:                     ChargeDelay();            // Wait as button discharges
9D003DEC  00000000   NOP
9D003DF0  00000000   NOP
137:                     ChargeDelay();            // Wait as button discharges
9D003DF4  00000000   NOP
9D003DF8  00000000   NOP
138:                     ChargeDelay();            // Wait as button discharges
9D003DFC  00000000   NOP
9D003E00  00000000   NOP
139:                 
140:                     CTMUCONbits.IDISSEN = 0;  // Unground charge pump
9D003E04  8C47A200   LW A3, -24064(V0)
9D003E08  7C074A44   INS A3, ZERO, 9, 1
9D003E0C  AC47A200   SW A3, -24064(V0)
141:                 
142:                     ChargeDelay();
9D003E10  00000000   NOP
9D003E14  00000000   NOP
143:                     CTMUCONbits.EDG1STAT = 1; // Start charging button
9D003E18  8C47A200   LW A3, -24064(V0)
9D003E1C  7CC7C604   INS A3, A2, 24, 1
9D003E20  AC47A200   SW A3, -24064(V0)
144:                 
145:                     CTMU_CHARGE_DELAYS;
9D003E24  00000000   NOP
9D003E28  00000000   NOP
9D003E2C  00000000   NOP
9D003E30  00000000   NOP
9D003E34  00000000   NOP
9D003E38  00000000   NOP
9D003E3C  00000000   NOP
9D003E40  00000000   NOP
9D003E44  00000000   NOP
9D003E48  00000000   NOP
9D003E4C  00000000   NOP
9D003E50  00000000   NOP
9D003E54  00000000   NOP
9D003E58  00000000   NOP
9D003E5C  00000000   NOP
9D003E60  00000000   NOP
9D003E64  00000000   NOP
9D003E68  00000000   NOP
9D003E6C  00000000   NOP
9D003E70  00000000   NOP
9D003E74  00000000   NOP
9D003E78  00000000   NOP
146:                 
147:                     CTMUCONbits.EDG1STAT = 0; // Stop charging button
9D003E7C  8C46A200   LW A2, -24064(V0)
9D003E80  7C06C604   INS A2, ZERO, 24, 1
9D003E84  AC46A200   SW A2, -24064(V0)
148:                     AD1CON1bits.SAMP = 0;     // Start A/D conversion
9D003E88  8C669000   LW A2, -28672(V1)
9D003E8C  7C060844   INS A2, ZERO, 1, 1
9D003E90  AC669000   SW A2, -28672(V1)
149:                 #if defined( TICKLE_LED1 )
150:                 //  PMADDRCLR = 1<<5;
151:                 //  LATCCLR = 1<<8;           // Turn off LED1 on Pin RPC8
152:                     LATCCLR = 1<<5;           // Turn off LED1 on Pin RPC5
153:                 #endif//defined( TICKLE_LED1 )
154:                 
155:                     //Wait for ADC conversion complete
156:                     //Enable interrupts while we wait for ADC to complete
157:                     asm("ei");
9D003E94  41606020   EI ZERO
158:                     while ( !AD1CON1bits.DONE )
9D003E98  8C679000   LW A3, -28672(V1)
9D003E9C  30E70001   ANDI A3, A3, 1
9D003EA0  10E0FFFD   BEQ A3, ZERO, 0x9D003E98
9D003EA4  3C06BF81   LUI A2, -16511
159:                     {
160:                         //Do Nothing
161:                     }
162:                     AD1CON1bits.DONE = 0;
9D003EA8  8CC39000   LW V1, -28672(A2)
9D003EAC  7C030004   INS V1, ZERO, 0, 1
9D003EB0  ACC39000   SW V1, -28672(A2)
163:                     CTMUCONbits.IDISSEN = 1;  // Ground charge pump
9D003EB4  8C43A200   LW V1, -24064(V0)
9D003EB8  24060001   ADDIU A2, ZERO, 1
9D003EBC  7CC34A44   INS V1, A2, 9, 1
9D003EC0  AC43A200   SW V1, -24064(V0)
164:                     switch ( iPort )
9D003EC4  2402000A   ADDIU V0, ZERO, 10
9D003EC8  10A20006   BEQ A1, V0, 0x9D003EE4
9D003ECC  3C02BF88   LUI V0, -16504
9D003ED0  2402000B   ADDIU V0, ZERO, 11
9D003ED4  54A20008   BNEL A1, V0, 0x9D003EF8
9D003ED8  3C02BF81   LUI V0, -16511
165:                     {
166:                         case 0xA:
167:                             TRISACLR = iPinBit;// Sensor pin now output to discharge button
9D003EE4  AC446014   SW A0, 24596(V0)
168:                             break;
9D003EE8  0B400FBE   J 0x9D003EF8
9D003EEC  3C02BF81   LUI V0, -16511
169:                         case 0xB:
170:                             TRISBCLR = iPinBit;// Sensor pin now output to discharge button
9D003EDC  0B400FBC   J 0x9D003EF0
9D003EE0  3C02BF88   LUI V0, -16504
9D003EF0  AC446114   SW A0, 24852(V0)
171:                             break;
172:                         case 0xC:
173:                 //            TRISCCLR = iPinBit;// Sensor pin now output to discharge button
174:                             break;
175:                     }
176:                 
177:                 //Read new Vpos
178:                     Vpos = ReadADC10(ReadActiveBufferADC10())<<6;
9D003EF4  3C02BF81   LUI V0, -16511
9D003EF8  8C439010   LW V1, -28656(V0)
9D003EFC  3C02BF81   LUI V0, -16511
9D003F00  24429070   ADDIU V0, V0, -28560
9D003F04  7C6301C0   EXT V1, V1, 7, 1
9D003F08  00031900   SLL V1, V1, 4
9D003F0C  00431021   ADDU V0, V0, V1
9D003F10  8C450000   LW A1, 0(V0)
9D003F28  00052980   SLL A1, A1, 6
9D003F2C  0B400FD1   J 0x9D003F44
9D003F30  30A5FFFF   ANDI A1, A1, -1
179:                 
180:                 #if defined(LIMIT_SLEW_RATE)
181:                     if ( IgnoreCurrentDataFlag == TRUE )
9D003F14  8F860008   LW A2, 8(GP)
9D003F18  24020001   ADDIU V0, ZERO, 1
9D003F1C  93840002   LBU A0, 2(GP)
9D003F20  10C20004   BEQ A2, V0, 0x9D003F34
9D003F24  3C03A000   LUI V1, -24576
182:                     {
183:                         Vpos = 0;
184:                         Vmeas = OldRawData[button_set_number];
9D003F34  00042840   SLL A1, A0, 1
9D003F38  2462017C   ADDIU V0, V1, 380
9D003F3C  00A21021   ADDU V0, A1, V0
9D003F40  94450000   LHU A1, 0(V0)
185:                     }
186:                     else
187:                     {
188:                         Vmeas = Vpos;
189:                     }
190:                 
191:                 #   define VMEAS_DELTA (1<<(6))
192:                     if     (Vmeas > OldRawData[button_set_number])
9D003F44  2462017C   ADDIU V0, V1, 380
9D003F48  00042040   SLL A0, A0, 1
9D003F4C  00822021   ADDU A0, A0, V0
9D003F50  94820000   LHU V0, 0(A0)
9D003F54  0045302B   SLTU A2, V0, A1
9D003F58  10C00003   BEQ A2, ZERO, 0x9D003F68
9D003F5C  00A2282B   SLTU A1, A1, V0
193:                     {
194:                        OldRawData[button_set_number] += VMEAS_DELTA;
9D003F60  0B400FDD   J 0x9D003F74
9D003F64  24420040   ADDIU V0, V0, 64
195:                     }
196:                     else if(Vmeas < OldRawData[button_set_number])
9D003F68  50A00004   BEQL A1, ZERO, 0x9D003F7C
9D003F6C  93820002   LBU V0, 2(GP)
197:                     {
198:                        OldRawData[button_set_number] -= VMEAS_DELTA;
9D003F70  2442FFC0   ADDIU V0, V0, -64
9D003F74  A4820000   SH V0, 0(A0)
199:                     }
200:                     Vupdate = OldRawData[button_set_number];
9D003F78  93820002   LBU V0, 2(GP)
9D003F8C  2463017C   ADDIU V1, V1, 380
9D003F90  00022840   SLL A1, V0, 1
9D003F94  00A31821   ADDU V1, A1, V1
201:                 
202:                 #else
203:                     if ( IgnoreCurrentDataFlag == TRUE )
204:                     {
205:                         Vmeas = Vpos = 0;
206:                         Vupdate = OldRawData[button_set_number];
207:                     }
208:                     else
209:                     {
210:                         OldRawData[button_set_number] = Vupdate = Vpos;
211:                     }
212:                 
213:                 #endif//defined(LIMIT_SLEW_RATE)
214:                 
215:                     ButtonCumulativeSum[button_set_number] += Vupdate;
9D003F7C  3C04A000   LUI A0, -24576
9D003F80  248400BC   ADDIU A0, A0, 188
9D003F84  00022880   SLL A1, V0, 2
9D003F88  00A42021   ADDU A0, A1, A0
9D003F98  94650000   LHU A1, 0(V1)
9D003F9C  8C830000   LW V1, 0(A0)
9D003FA8  00A31821   ADDU V1, A1, V1
9D003FAC  AC830000   SW V1, 0(A0)
216:                 
217:                 #if defined( UART_DUMP_RAW_COUNTS )
218:                     CurRawData[  HF_Read_Number  ][button_set_number] = Vmeas;
219:                 #elif defined( UART_DUMP_ALL_COUNTS )
220:                     CurRawData[3*HF_Read_Number+0][button_set_number] = Vpos;
221:                     CurRawData[3*HF_Read_Number+1][button_set_number] = 0; // No Vneg
222:                     CurRawData[3*HF_Read_Number+2][button_set_number] = Vmeas;
223:                 #endif//defined( UART_DUMP_RAW_COUNTS )
224:                 
225:                     //Next Measurement??
226:                     button_set_number++; //Increment the button number to move on to the next button
9D003FA0  24420001   ADDIU V0, V0, 1
9D003FA4  304200FF   ANDI V0, V0, 255
227:                     if(button_set_number == NumberScanChannels) //if scanned all the buttons
9D003FB0  93830001   LBU V1, 1(GP)
9D003FB4  1462000D   BNE V1, V0, 0x9D003FEC
9D003FB8  A3820002   SB V0, 2(GP)
228:                     {
229:                         HF_Read_Number++;      //Start the next set of HF Scans
9D003FBC  93820003   LBU V0, 3(GP)
9D003FC4  24420001   ADDIU V0, V0, 1
9D003FC8  304200FF   ANDI V0, V0, 255
9D003FCC  A3820003   SB V0, 3(GP)
230:                         button_set_number = 0; //Start over at the first button
9D003FC0  A3800002   SB ZERO, 2(GP)
231:                         if ( HF_Read_Number < NUM_HF_READS ) // Not done with scans
9D003FD0  2C420020   SLTIU V0, V0, 32
9D003FD4  14400005   BNE V0, ZERO, 0x9D003FEC
9D003FD8  00000000   NOP
232:                         {
233:                             EmTouchDataReady = FALSE;
234:                         }
235:                         else  //All HF scans done, compute average, signal we're done
236:                         {
237:                             EmTouchDataReady = TRUE; // We're done with complete scan
9D003FDC  24020001   ADDIU V0, ZERO, 1
9D003FE0  A3820010   SB V0, 16(GP)
238:                             HF_Read_Number = 0;  // Start next set of HF scans
9D003FE4  03E00008   JR RA
9D003FE8  A3800003   SB ZERO, 3(GP)
239:                         }
240:                     }
241:                     else
242:                     {
243:                         EmTouchDataReady = FALSE;
9D003FEC  A3800010   SB ZERO, 16(GP)
9D003FF0  03E00008   JR RA
9D003FF4  00000000   NOP
244:                     }
245:                 
246:                     return; // we're done!
247:                 }
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/Microchip/Common/TimeDelay.c  --------------------------
1:                   /******************************************************************************
2:                   
3:                   File Name:       TimeDelay.c
4:                   Dependencies:    None
5:                   Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32
6:                   Compiler:        C30 v3.12
7:                   Company:         Microchip Technology, Inc.
8:                   
9:                   Copyright (C) 2010 Microchip Technology Inc.  All rights reserved.
10:                  
11:                  Microchip licenses to you the right to use, modify, copy and distribute 
12:                  Software only when embedded on a Microchip microcontroller or digital signal 
13:                  controller that is integrated into your product or third party product 
14:                  (pursuant to the sublicense terms in the accompanying license agreement).  
15:                  
16:                  You should refer to the license agreement accompanying this Software for 
17:                  additional information regarding your rights and obligations.
18:                  
19:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
20:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF 
21:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. 
22:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER 
23:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR 
24:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES 
25:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR 
26:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF 
27:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES 
28:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
29:                  
30:                  Author          Date    Comments
31:                  --------------------------------------------------------------------------------
32:                  AKN	2009.10.14	FILE CREATED
33:                  AKN	2009.10.15	CHANGED C18 DELAY ROUTINE TO DECREMENT ENTIRE NUMBER OF CYCLES
34:                  AKN	2009.10.19	CHANGED C30 DELAY ROUTINE TO MATCH C18 IMPLEMENTATION
35:                  AKN	2009.10.26	ADDED C32 DELAY ROUTINE TO MATCH C18 IMPLEMENTATION
36:                  AKN	2009.10.27	CONSOLIDATED C30 AND C32 IMPLEMENTATIONS, ADDED PADDING TO
37:                                  MAKE C30 DELAYS MORE ACCURATE
38:                  PAT	2010.01.26	CONVERTED LOCALS TO VOLATILE 
39:                  PAT	2010.03.07	ADDED include "Compiler.h"
40:                  *******************************************************************************/
41:                  #if defined(__PIC32MX__)
42:                  	#include <plib.h>
43:                  #endif
44:                  #include "..\include\Compiler.h"
45:                  #include "..\..\HardwareProfile.h"
46:                  #include "..\Include\TimeDelay.h"
47:                  
48:                  /****************************************************************************
49:                    Function:
50:                      void Delay10us( UINT32 tenMicroSecondCounter )
51:                  
52:                    Description:
53:                      This routine performs a software delay in intervals of 10 microseconds.
54:                  
55:                    Precondition:
56:                      None
57:                  
58:                    Parameters:
59:                      UINT32 tenMicroSecondCounter - number of ten microsecond delays
60:                      to perform at once.
61:                  
62:                    Returns:
63:                      None
64:                  
65:                    Remarks:
66:                      None
67:                    ***************************************************************************/
68:                  void Delay10us( UINT32 tenMicroSecondCounter )
69:                  {
9D002194  27BDFFF8   ADDIU SP, SP, -8
70:                      volatile INT32 cyclesRequiredForEntireDelay;    
71:                          
72:                      #if defined(__18CXX)
73:                      
74:                          if (GetInstructionClock() <= 2500000) //for all FCY speeds under 2MHz (FOSC <= 10MHz)
75:                          {
76:                              //26 cycles burned through this path (includes return to caller).
77:                              //For FOSC == 1MHZ, it takes 104us.
78:                              //For FOSC == 4MHZ, it takes 26us
79:                              //For FOSC == 8MHZ, it takes 13us.
80:                              //For FOSC == 10MHZ, it takes 10.5us.
81:                          }
82:                          else
83:                          {
84:                              //14 cycles burned to this point.
85:                              
86:                              //We want to pre-calculate number of cycles required to delay 10us * tenMicroSecondCounter using a 1 cycle granule.
87:                              cyclesRequiredForEntireDelay = (INT32)(GetInstructionClock()/100000) * tenMicroSecondCounter;
88:                              
89:                              //We subtract all the cycles used up until we reach the while loop below, where each loop cycle count is subtracted.
90:                              //Also we subtract the 22 cycle function return.
91:                              cyclesRequiredForEntireDelay -= (153 + 22);
92:                              
93:                              if (cyclesRequiredForEntireDelay <= 45)
94:                              {
95:                                  // If we have exceeded the cycle count already, bail! Best compromise between FOSC == 12MHz and FOSC == 24MHz.
96:                              }    
97:                              else
98:                              {
99:                                  //Try as you may, you can't get out of this heavier-duty case under 30us. ;]
100:                                 
101:                                 while (cyclesRequiredForEntireDelay>0) //153 cycles used to this point.
102:                                 {
103:                                     Nop(); //Delay one instruction cycle at a time, not absolutely necessary.
104:                                     cyclesRequiredForEntireDelay -= 42; //Subtract cycles burned while doing each delay stage, 42 in this case.
105:                                 }
106:                             }
107:                         }
108:                     
109:                     #elif defined(__C30__) || defined(__PIC32MX__)
110:                     
111:                         if(GetInstructionClock() <= 500000) //for all FCY speeds under 500KHz (FOSC <= 1MHz)
112:                         {
113:                             //10 cycles burned through this path (includes return to caller).
114:                             //For FOSC == 1MHZ, it takes 5us.
115:                             //For FOSC == 4MHZ, it takes 0.5us
116:                             //For FOSC == 8MHZ, it takes 0.25us.
117:                             //For FOSC == 10MHZ, it takes 0.2us.
118:                         }    
119:                         else
120:                         {
121:                             //7 cycles burned to this point.
122:                             
123:                             //We want to pre-calculate number of cycles required to delay 10us * tenMicroSecondCounter using a 1 cycle granule.
124:                             cyclesRequiredForEntireDelay = (INT32)(GetInstructionClock()/100000)*tenMicroSecondCounter;
9D00218C  24020190   ADDIU V0, ZERO, 400
9D002190  70821002   MUL V0, A0, V0
9D002198  AFA20000   SW V0, 0(SP)
125:                             
126:                             #if defined(__C30__)
127:                                 //We subtract all the cycles used up until we reach the while loop below, where each loop cycle count is subtracted.
128:                                 //Also we subtract the 5 cycle function return.
129:                                 cyclesRequiredForEntireDelay -= 44; //(29 + 5) + 10 cycles padding
130:                             #elif defined(__PIC32MX__)
131:                                 //We subtract all the cycles used up until we reach the while loop below, where each loop cycle count is subtracted.
132:                                 //Also we subtract the 5 cycle function return.
133:                                 cyclesRequiredForEntireDelay -= 24; //(19 + 5)
9D00219C  8FA20000   LW V0, 0(SP)
9D0021A0  2442FFE8   ADDIU V0, V0, -24
9D0021A4  AFA20000   SW V0, 0(SP)
134:                             #endif
135:                             
136:                             if(cyclesRequiredForEntireDelay <= 0)
9D0021A8  8FA20000   LW V0, 0(SP)
9D0021AC  1C400006   BGTZ V0, 0x9D0021C8
9D0021B0  00000000   NOP
137:                             {
138:                                 // If we have exceeded the cycle count already, bail!
139:                             }
140:                             else
141:                             {   
142:                                 while(cyclesRequiredForEntireDelay>0) //19 cycles used to this point.
9D0021C8  8FA20000   LW V0, 0(SP)
9D0021CC  1C40FFFB   BGTZ V0, 0x9D0021BC
9D0021D0  00000000   NOP
143:                                 {
144:                                     #if defined(__C30__)
145:                                         cyclesRequiredForEntireDelay -= 11; //Subtract cycles burned while doing each delay stage, 12 in this case. Add one cycle as padding.
146:                                     #elif defined(__PIC32MX__)
147:                                         cyclesRequiredForEntireDelay -= 8; //Subtract cycles burned while doing each delay stage, 8 in this case.
9D0021BC  8FA20000   LW V0, 0(SP)
9D0021C0  2442FFF8   ADDIU V0, V0, -8
9D0021C4  AFA20000   SW V0, 0(SP)
148:                                     #endif
149:                                 }
150:                             }
151:                         }
152:                     #endif
153:                 }
9D0021B4  0B400876   J 0x9D0021D8
9D0021B8  27BD0008   ADDIU SP, SP, 8
9D0021D4  27BD0008   ADDIU SP, SP, 8
9D0021D8  03E00008   JR RA
9D0021DC  00000000   NOP
154:                 
155:                 /****************************************************************************
156:                   Function:
157:                     void DelayMs( UINT16 ms )
158:                 
159:                   Description:
160:                     This routine performs a software delay in intervals of 1 millisecond.
161:                 
162:                   Precondition:
163:                     None
164:                 
165:                   Parameters:
166:                     UINT16 ms - number of one millisecond delays to perform at once.
167:                 
168:                   Returns:
169:                     None
170:                 
171:                   Remarks:
172:                     None
173:                   ***************************************************************************/
174:                 void DelayMs( UINT16 ms )
175:                 {
9D0021E0  27BDFFD8   ADDIU SP, SP, -40
9D0021E4  AFB10020   SW S1, 32(SP)
9D0021E8  AFB0001C   SW S0, 28(SP)
9D0021EC  AFBF0024   SW RA, 36(SP)
9D0021F0  3090FFFF   ANDI S0, A0, -1
176:                     #if defined(__18CXX)
177:                         
178:                         INT32 cyclesRequiredForEntireDelay;
179:                         
180:                         // We want to pre-calculate number of cycles required to delay 1ms, using a 1 cycle granule.
181:                         cyclesRequiredForEntireDelay = (signed long)(GetInstructionClock()/1000) * ms;
182:                         
183:                         // We subtract all the cycles used up until we reach the while loop below, where each loop cycle count is subtracted.
184:                         // Also we subtract the 22 cycle function return.
185:                         cyclesRequiredForEntireDelay -= (148 + 22);
186:                 
187:                         if (cyclesRequiredForEntireDelay <= (170+25)) 
188:                         {
189:                             return;     // If we have exceeded the cycle count already, bail!
190:                         }    
191:                         else
192:                         {
193:                             while (cyclesRequiredForEntireDelay > 0) //148 cycles used to this point.
194:                             {
195:                                 Nop();                              // Delay one instruction cycle at a time, not absolutely necessary.
196:                                 cyclesRequiredForEntireDelay -= 39; // Subtract cycles burned while doing each delay stage, 39 in this case.
197:                             }
198:                         }
199:                         
200:                     #elif defined(__C30__) || defined(__PIC32MX__)
201:                     
202:                         volatile UINT8 i;
203:                         
204:                         while (ms--)
9D0021F4  0B40088D   J 0x9D002234
9D0021F8  24110004   ADDIU S1, ZERO, 4
9D002234  1600FFF1   BNE S0, ZERO, 0x9D0021FC
9D002238  8FBF0024   LW RA, 36(SP)
205:                         {
206:                             i = 4;
9D0021FC  A3B10010   SB S1, 16(SP)
207:                             while (i--)
9D002200  0B400884   J 0x9D002210
9D002204  00000000   NOP
9D002210  93A20010   LBU V0, 16(SP)
9D002214  304200FF   ANDI V0, V0, 255
9D002218  2443FFFF   ADDIU V1, V0, -1
9D00221C  306300FF   ANDI V1, V1, 255
9D002220  A3A30010   SB V1, 16(SP)
9D002224  1440FFF8   BNE V0, ZERO, 0x9D002208
9D002228  00000000   NOP
9D00222C  2610FFFF   ADDIU S0, S0, -1
9D002230  3210FFFF   ANDI S0, S0, -1
208:                             {
209:                                 Delay10us( 25 );
9D002208  0F400863   JAL Delay10us
9D00220C  24040019   ADDIU A0, ZERO, 25
210:                             }
211:                         }
212:                     #endif
213:                 }
9D00223C  8FB10020   LW S1, 32(SP)
9D002240  8FB0001C   LW S0, 28(SP)
9D002244  03E00008   JR RA
9D002248  27BD0028   ADDIU SP, SP, 40
214:                 
---  C:/+MyDev/+PIC32MixMode/PIC32MM_mTOUCH_28.X/CoreMain.c  --------------------------------------------
1:                   /* 
2:                    * File:   newmain.c
3:                    * Author: MRush
4:                    *
5:                    * Created on December 2, 2013, 5:23 PM
6:                    */
7:                   
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  #include <p32xxxx.h>                // Processor defs
11:                  #include <plib.h>
12:                  #include <math.h>
13:                  #include "HMain.h"
14:                  
15:                  #include "Microchip\Include\GenericTypeDefs.h"
16:                  #include "mTouchConfig.h"
17:                  #include "HardwareProfile.h"
18:                  //#include "Graphics.h"
19:                  #include "peripheral\pps.h"
20:                  #include "mTouchCapLib\mTouchCapAPI.h"
21:                  #include "mTouchCapLib\mTouchCapLED.h"
22:                  #include "mTouchCapLib\mTouchCapAPP_DirectKeys.h"
23:                  //#include "SwitchCode.h"
24:                  #include "mTouchCapLib\mTouchCapStatus.h"
25:                  //#include DISPLAY_FONT_HEADER
26:                  #include "Microchip\Include\TimeDelay.h"
27:                  
28:                  
29:                  
30:                  
31:                      #pragma config FPLLMUL = MUL_20, FPLLIDIV = DIV_2, FPLLODIV = DIV_2
32:                      #pragma config POSCMOD = HS, FNOSC = PRIPLL, FPBDIV = DIV_1
33:                  
34:                  //#pragma config FPLLMUL = MUL_20, FPLLIDIV = DIV_2, FPLLODIV = DIV_2
35:                      #pragma config FWDTEN = OFF
36:                  //    #pragma config POSCMOD = OFF, FNOSC = FRCPLL
37:                  //    #pragma config FPBDIV = DIV_1, FSOSCEN = OFF
38:                      #pragma config FSOSCEN = OFF
39:                      #pragma config WDTPS = PS4
40:                      #pragma config CP=OFF, BWP=OFF
41:                      #pragma config FCKSM = CSDCMD
42:                      #pragma config ICESEL   = ICS_PGx1      // ICE/ICD Comm Channel Select
43:                      #pragma config JTAGEN = OFF
44:                  
45:                      //USB
46:                      #pragma config FUSBIDIO = OFF
47:                      #pragma config FVBUSONIO = OFF
48:                  
49:                  //    #define SYS_FREQ 				(40000000L)
50:                  
51:                  
52:                  //#define PIC32MX2
53:                  
54:                  unsigned int g_count;
55:                  
56:                  void SendDataBuffer(const CHAR *buffer, UINT32 size);
57:                  
58:                  extern volatile UINT8 EmTouchDataReady;//global indicating the reading of all channels finished
59:                  
60:                  
61:                  #define  NOP() asm("NOP");
62:                  
63:                  
64:                  //#=================================================================================================
65:                  //#=================================================================================================
66:                  //# Delayus : 9D002500
67:                  //#-------------------------------------------------------------------------------------------------
68:                  void  __attribute__((section("XCode2"))) Delayus(unsigned int t)
69:                  {
9D000900  27BDFFE8   ADDIU SP, SP, -24
9D000904  AFB00010   SW S0, 16(SP)
9D000908  00808021   ADDU S0, A0, ZERO
9D00090C  AFBF0014   SW RA, 20(SP)
70:                      unsigned int CalT;
71:                      WriteCoreTimer(0);
9D000910  0F400908   JAL WriteCoreTimer
9D000914  00002021   ADDU A0, ZERO, ZERO
72:                      CalT = t * 20;
9D000918  24020014   ADDIU V0, ZERO, 20
9D00091C  72028002   MUL S0, S0, V0
73:                      //asm(" nop ");
74:                      while ( (unsigned int)(ReadCoreTimer()) < CalT ) {};
9D000920  0F400906   JAL ReadCoreTimer
9D000924  00000000   NOP
9D000928  0050102B   SLTU V0, V0, S0
9D00092C  1440FFFC   BNE V0, ZERO, 0x9D000920
9D000930  8FBF0014   LW RA, 20(SP)
75:                      //while(--CalT)
76:                      //{
77:                      //asm(" nop ");
78:                      //}
79:                  } //Delayus
9D000934  8FB00010   LW S0, 16(SP)
9D000938  03E00008   JR RA
9D00093C  27BD0018   ADDIU SP, SP, 24
80:                  //#=================================================================================================
81:                  //# Delayms : 9D002550
82:                  //#-------------------------------------------------------------------------------------------------
83:                  void  __attribute__((section("XCode2"))) Delayms(unsigned int t)
84:                  {
9D000940  27BDFFE8   ADDIU SP, SP, -24
9D000944  AFB00010   SW S0, 16(SP)
9D000948  AFBF0014   SW RA, 20(SP)
85:                      //unsigned int T = 0;
86:                      //while ( (T++) < t )
87:                      while (t--)
9D00094C  0B400258   J 0x9D000960
9D000950  00808021   ADDU S0, A0, ZERO
9D000960  1600FFFC   BNE S0, ZERO, 0x9D000954
9D000964  8FBF0014   LW RA, 20(SP)
88:                      {
89:                          Delayus(999);
9D000954  0F400240   JAL Delayus
9D000958  240403E7   ADDIU A0, ZERO, 999
9D00095C  2610FFFF   ADDIU S0, S0, -1
90:                      }
91:                  } //Delayms
9D000968  8FB00010   LW S0, 16(SP)
9D00096C  03E00008   JR RA
9D000970  27BD0018   ADDIU SP, SP, 24
92:                  
93:                  
94:                  //#=================================================================================================
95:                  // COMM1_Tx : 9D0025B8
96:                  //#=================================================================================================
97:                  //#-------------------------------------------------------------------------------------------------
98:                  void __attribute__((section("XCode2"))) COMM1_Tx(unsigned int d)
99:                  {
100:                     while( U1STAbits.UTXBF);
9D000974  3C02BF80   LUI V0, -16512
9D000978  8C456010   LW A1, 24592(V0)
9D00097C  30A50200   ANDI A1, A1, 512
9D000980  14A0FFFD   BNE A1, ZERO, 0x9D000978
9D000984  3C03BF80   LUI V1, -16512
101:                     putcUART1(d);
9D000988  8C626010   LW V0, 24592(V1)
9D00098C  30420100   ANDI V0, V0, 256
9D000990  1040FFFD   BEQ V0, ZERO, 0x9D000988
9D000994  3C02BF80   LUI V0, -16512
9D000998  AC446020   SW A0, 24608(V0)
102:                 }
9D00099C  03E00008   JR RA
9D0009A0  00000000   NOP
103:                 //#=================================================================================================
104:                 // COMM1_Tx_Str : 9D002614
105:                 //#-------------------------------------------------------------------------------------------------
106:                 void __attribute__((section("XCode2"))) COMM1_Tx_Str(unsigned char *str)
107:                 {
9D0009A4  27BDFFE8   ADDIU SP, SP, -24
9D0009A8  AFB00010   SW S0, 16(SP)
9D0009AC  AFBF0014   SW RA, 20(SP)
108:                     while ((*str) != '\0')
9D0009B0  0B400270   J 0x9D0009C0
9D0009B4  00808021   ADDU S0, A0, ZERO
9D0009C0  92040000   LBU A0, 0(S0)
9D0009C4  1480FFFC   BNE A0, ZERO, 0x9D0009B8
9D0009C8  8FBF0014   LW RA, 20(SP)
109:                     {
110:                         COMM1_Tx(*str );
9D0009B8  0F40025D   JAL COMM1_Tx
9D0009BC  26100001   ADDIU S0, S0, 1
111:                         *(str++);
112:                     }
113:                 }
9D0009CC  8FB00010   LW S0, 16(SP)
9D0009D0  03E00008   JR RA
9D0009D4  27BD0018   ADDIU SP, SP, 24
114:                 
115:                 //-----------------------------------------------==================================================
116:                 // XCode2Dat
117:                 //-----------------------------------------------==================================================
118:                 const __attribute__((  address(0x9d0008f0)  )) char dig[16] =
119:                 //const __attribute__((section("XCode2Dat"))) char dig[] =
120:                         "0123456789"
121:                         "ABCDEF";
122:                 //-----------------------------------------------==================================================
123:                 /* The Itoa code is in the puiblic domain */
124:                 void __attribute__((section("XCode2"))) Math_Itoa(int value, char* str, int radix)
9D000A08  00A24021   ADDU T0, A1, V0
125:                 {
126:                 //    static char dig[] =
127:                 //        "0123456789"
128:                 //        "ABCEDF";
129:                     int n = 0, neg = 0;
9D0009F8  00001021   ADDU V0, ZERO, ZERO
130:                     unsigned int v;
131:                     char* p, *q;
132:                     char c;
133:                     if (radix == 10 && value < 0) {
9D0009D8  2402000A   ADDIU V0, ZERO, 10
9D0009DC  14C20005   BNE A2, V0, 0x9D0009F4
9D0009E0  00001821   ADDU V1, ZERO, ZERO
9D0009E4  04810004   BGEZ A0, 0x9D0009F8
9D0009E8  3C079D00   LUI A3, -25344
134:                         value = -value;
9D0009EC  00042023   SUBU A0, ZERO, A0
135:                         neg = 1;
9D0009F0  24030001   ADDIU V1, ZERO, 1
136:                     }
137:                     v = value;
138:                     do {
139:                         str[n++] = dig[v%radix];
9D0009F4  3C079D00   LUI A3, -25344
9D0009FC  24E708F0   ADDIU A3, A3, 2288
9D000A00  0086001B   DIVU A0, A2
9D000A04  00C001F4   TEQ A2, ZERO
9D000A0C  24420001   ADDIU V0, V0, 1
9D000A10  00004810   MFHI T1, 0
9D000A14  01274821   ADDU T1, T1, A3
9D000A18  91290000   LBU T1, 0(T1)
9D000A1C  00002012   MFLO A0, 0
140:                         v /= radix;
141:                     } while (v);
9D000A20  1480FFF7   BNE A0, ZERO, 0x9D000A00
9D000A24  A1090000   SB T1, 0(T0)
142:                     if (neg)
9D000A28  10600005   BEQ V1, ZERO, 0x9D000A40
9D000A2C  00A21821   ADDU V1, A1, V0
143:                         str[n++] = '-';
9D000A30  2406002D   ADDIU A2, ZERO, 45
9D000A34  A0660000   SB A2, 0(V1)
9D000A38  24420001   ADDIU V0, V0, 1
144:                     str[n] = '\0';
9D000A3C  00A21821   ADDU V1, A1, V0
9D000A40  A0600000   SB ZERO, 0(V1)
145:                 
146:                     //for (p = str, q = p + n/2; p != q; ++p, --q)
147:                     //    c = *p, *p = *q, *q = c;
148:                 	//now we need to reverse res
149:                 	for(v = 0; v < n/2; ++v)
9D000A44  0B400299   J 0x9D000A64
9D000A48  00021043   SRA V0, V0, 1
9D000A54  24840001   ADDIU A0, A0, 1
9D000A60  24A50001   ADDIU A1, A1, 1
9D000A64  0082302B   SLTU A2, A0, V0
9D000A68  14C0FFF8   BNE A2, ZERO, 0x9D000A4C
9D000A6C  2463FFFF   ADDIU V1, V1, -1
150:                 	{
151:                 	   c = str[v]; str[v] = str[n-v-1]; str[n-v-1] = c;
9D000A4C  80A60000   LB A2, 0(A1)
9D000A50  90670000   LBU A3, 0(V1)
9D000A58  A0A70000   SB A3, 0(A1)
9D000A5C  A0660000   SB A2, 0(V1)
152:                 	}
153:                 }
9D000A70  03E00008   JR RA
9D000A74  00000000   NOP
154:                 //-----------------------------------------------==================================================
155:                 void __attribute__((section("XCode2"))) DebugPrint_Dec(int x)
156:                 {
9D000A78  27BDFFC8   ADDIU SP, SP, -56
9D000A80  AFBF0034   SW RA, 52(SP)
157:                     unsigned char OS_Str_1[32];
158:                 
159:                     Math_Itoa(x,OS_Str_1,10);
9D000A7C  27A50010   ADDIU A1, SP, 16
9D000A84  0F400276   JAL Math_Itoa
9D000A88  2406000A   ADDIU A2, ZERO, 10
160:                     COMM1_Tx_Str(OS_Str_1);
9D000A8C  0F400269   JAL COMM1_Tx_Str
9D000A90  27A40010   ADDIU A0, SP, 16
161:                 }
9D000A94  8FBF0034   LW RA, 52(SP)
9D000A98  03E00008   JR RA
9D000A9C  27BD0038   ADDIU SP, SP, 56
162:                 //-----------------------------------------------==================================================
163:                 void __attribute__((section("XCode2"))) DebugPrint_Hex(int x)
164:                 {
9D000AA0  27BDFFC8   ADDIU SP, SP, -56
9D000AA8  AFBF0034   SW RA, 52(SP)
165:                     unsigned char OS_Str_1[32];
166:                 
167:                     Math_Itoa(x,OS_Str_1,16);
9D000AA4  27A50010   ADDIU A1, SP, 16
9D000AAC  0F400276   JAL Math_Itoa
9D000AB0  24060010   ADDIU A2, ZERO, 16
168:                     COMM1_Tx_Str(OS_Str_1);
9D000AB4  0F400269   JAL COMM1_Tx_Str
9D000AB8  27A40010   ADDIU A0, SP, 16
169:                 }
9D000ABC  8FBF0034   LW RA, 52(SP)
9D000AC0  03E00008   JR RA
9D000AC4  27BD0038   ADDIU SP, SP, 56
170:                 void __attribute__((section("XCode2"))) DebugPrint_CR( void )
171:                 {
172:                     COMM1_Tx(13);
9D000AC8  0B40025D   J COMM1_Tx
9D000ACC  2404000D   ADDIU A0, ZERO, 13
173:                 }
174:                 void __attribute__((section("XCode2"))) DebugPrint_Space( void )
175:                 {
176:                     COMM1_Tx(' ');
9D000AD0  0B40025D   J COMM1_Tx
9D000AD4  24040020   ADDIU A0, ZERO, 32
177:                 }
178:                 
179:                 //-----------------------------------------------==================================================
180:                 //#-------------------------------------------------------------------------------------------------
181:                 void __attribute__((section("XCode2"))) COMM2_Tx(unsigned int d)
182:                 {
183:                     while( U2STAbits.UTXBF);
9D000AD8  3C02BF80   LUI V0, -16512
9D000ADC  8C456210   LW A1, 25104(V0)
9D000AE0  30A50200   ANDI A1, A1, 512
9D000AE4  14A0FFFD   BNE A1, ZERO, 0x9D000ADC
9D000AE8  3C03BF80   LUI V1, -16512
184:                     putcUART2(d);
9D000AEC  8C626210   LW V0, 25104(V1)
9D000AF0  30420100   ANDI V0, V0, 256
9D000AF4  1040FFFD   BEQ V0, ZERO, 0x9D000AEC
9D000AF8  3C02BF80   LUI V0, -16512
9D000AFC  AC446220   SW A0, 25120(V0)
185:                 }
9D000B00  03E00008   JR RA
9D000B04  00000000   NOP
186:                 void __attribute__((section("XCode2"))) COMM2_Tx_Str(unsigned char *str)
187:                 {
9D000B08  27BDFFE8   ADDIU SP, SP, -24
9D000B0C  AFB00010   SW S0, 16(SP)
9D000B10  AFBF0014   SW RA, 20(SP)
188:                     while ((*str) != '\0')
9D000B14  0B4002C9   J 0x9D000B24
9D000B18  00808021   ADDU S0, A0, ZERO
9D000B24  92040000   LBU A0, 0(S0)
9D000B28  1480FFFC   BNE A0, ZERO, 0x9D000B1C
9D000B2C  8FBF0014   LW RA, 20(SP)
189:                     {
190:                         COMM2_Tx(*str );
9D000B1C  0F4002B6   JAL COMM2_Tx
9D000B20  26100001   ADDIU S0, S0, 1
191:                         *(str++);
192:                     }
193:                 }
9D000B30  8FB00010   LW S0, 16(SP)
9D000B34  03E00008   JR RA
9D000B38  27BD0018   ADDIU SP, SP, 24
194:                 void __attribute__((section("XCode2"))) COMM2Print_Dec(int x)
195:                 {
9D000B3C  27BDFFC8   ADDIU SP, SP, -56
9D000B44  AFBF0034   SW RA, 52(SP)
196:                     unsigned char OS_Str_1[32];
197:                 
198:                     Math_Itoa(x,OS_Str_1,10);
9D000B40  27A50010   ADDIU A1, SP, 16
9D000B48  0F400276   JAL Math_Itoa
9D000B4C  2406000A   ADDIU A2, ZERO, 10
199:                     COMM2_Tx_Str(OS_Str_1);
9D000B50  0F4002C2   JAL COMM2_Tx_Str
9D000B54  27A40010   ADDIU A0, SP, 16
200:                 }
9D000B58  8FBF0034   LW RA, 52(SP)
9D000B5C  03E00008   JR RA
9D000B60  27BD0038   ADDIU SP, SP, 56
201:                 void __attribute__((section("XCode2"))) COMM2Print_Hex(int x)
202:                 {
9D000B64  27BDFFC8   ADDIU SP, SP, -56
9D000B6C  AFBF0034   SW RA, 52(SP)
203:                     unsigned char OS_Str_1[32];
204:                 
205:                     Math_Itoa(x,OS_Str_1,16);
9D000B68  27A50010   ADDIU A1, SP, 16
9D000B70  0F400276   JAL Math_Itoa
9D000B74  24060010   ADDIU A2, ZERO, 16
206:                     COMM2_Tx_Str(OS_Str_1);
9D000B78  0F4002C2   JAL COMM2_Tx_Str
9D000B7C  27A40010   ADDIU A0, SP, 16
207:                 }
9D000B80  8FBF0034   LW RA, 52(SP)
9D000B84  03E00008   JR RA
9D000B88  27BD0038   ADDIU SP, SP, 56
208:                 void __attribute__((section("XCode2"))) COMM2Print_CR( void )
209:                 {
210:                     COMM2_Tx(13);
9D000B8C  0B4002B6   J COMM2_Tx
9D000B90  2404000D   ADDIU A0, ZERO, 13
211:                 }
212:                 void __attribute__((section("XCode2"))) COMM2Print_Space( void )
213:                 {
214:                     COMM2_Tx(' ');
9D000B94  0B4002B6   J COMM2_Tx
9D000B98  24040020   ADDIU A0, ZERO, 32
215:                 }
216:                 //-----------------------------------------------==================================================
217:                 //-----------------------------------------------==================================================
218:                 //#=================================================================================================
219:                 
220:                 //#=================================================================================================
221:                 void __attribute__((section("XCode2"))) INT0_INIT( void )
222:                 {
223:                 //ConfigINT0(EXT_INT_PRI_1 | RISING_EDGE_INT | EXT_INT_ENABLE);
224:                 ConfigINT0(EXT_INT_PRI_2 | FALLING_EDGE_INT | EXT_INT_ENABLE);
9D000B9C  24020008   ADDIU V0, ZERO, 8
9D000BA0  3C03BF88   LUI V1, -16504
9D000BA4  AC621034   SW V0, 4148(V1)
9D000BA8  3C041C00   LUI A0, 7168
9D000BAC  3C03BF88   LUI V1, -16504
9D000BB0  AC641094   SW A0, 4244(V1)
9D000BB4  3C040800   LUI A0, 2048
9D000BB8  3C03BF88   LUI V1, -16504
9D000BBC  AC641098   SW A0, 4248(V1)
9D000BC0  3C03BF88   LUI V1, -16504
9D000BC4  24040001   ADDIU A0, ZERO, 1
9D000BC8  AC641004   SW A0, 4100(V1)
9D000BCC  3C03BF88   LUI V1, -16504
9D000BD0  AC601008   SW ZERO, 4104(V1)
9D000BD4  3C03BF88   LUI V1, -16504
9D000BD8  AC621064   SW V0, 4196(V1)
9D000BDC  3C03BF88   LUI V1, -16504
9D000BE0  AC621068   SW V0, 4200(V1)
225:                 }//INT0_INIT
9D000BE4  03E00008   JR RA
9D000BE8  00000000   NOP
226:                 //#-------------------------------------------------------------------------------------------------
227:                 //#=================================================================================================
228:                 #ifdef OLD_CORE
229:                 //#=================================================================================================
230:                 //#=================================================================================================
231:                 void __attribute__((section("XCodeInt"))) __ISR( _EXTERNAL_4_VECTOR, ipl1) INT0Interrupt( void)
232:                 { // input capture interrupt service routine
233:                    //_RA1 = ~_RA1;
234:                    Delayms(10);
235:                    SoftReset();
236:                    mINT4ClearIntFlag();
237:                 }
238:                 
239:                 void __attribute__((section("XCodeIntPre"))) INT4_INIT( void )
240:                 {
241:                 //ConfigINT0(EXT_INT_PRI_1 | RISING_EDGE_INT | EXT_INT_ENABLE);
242:                 
243:                     _TRISB3 = 1;
244:                     INT4Rbits.INT4R = 1; //SET int4 to RPB3
245:                 
246:                 ConfigINT4(EXT_INT_PRI_1 | FALLING_EDGE_INT | EXT_INT_ENABLE);
247:                 }//INT0_INIT
248:                 
249:                 
250:                 #else
251:                 //#=================================================================================================
252:                 //#=================================================================================================
253:                 void __attribute__((section("XCodeInt"))) __ISR( _EXTERNAL_0_VECTOR, ipl2) INT0Interrupt( void)
254:                 { // input capture interrupt service routine
9D000800  415DE800   RDPGPR SP, SP
9D000804  401A7000   MFC0 K0, EPC
9D000808  401B6000   MFC0 K1, Status
9D00080C  27BDFF98   ADDIU SP, SP, -104
9D000810  AFBB0060   SW K1, 96(SP)
9D000814  7C1B7844   INS K1, ZERO, 1, 15
9D000818  377B0800   ORI K1, K1, 2048
9D00081C  AFBA0064   SW K0, 100(SP)
9D000820  409B6000   MTC0 K1, Status
9D000824  AFBF0054   SW RA, 84(SP)
9D000828  AFB90050   SW T9, 80(SP)
9D00082C  AFB8004C   SW T8, 76(SP)
9D000830  AFAF0048   SW T7, 72(SP)
9D000834  AFAE0044   SW T6, 68(SP)
9D000838  AFAD0040   SW T5, 64(SP)
9D00083C  AFAC003C   SW T4, 60(SP)
9D000840  AFAB0038   SW T3, 56(SP)
9D000844  AFAA0034   SW T2, 52(SP)
9D000848  AFA90030   SW T1, 48(SP)
9D00084C  AFA8002C   SW T0, 44(SP)
9D000850  AFA70028   SW A3, 40(SP)
9D000854  AFA60024   SW A2, 36(SP)
9D000858  AFA50020   SW A1, 32(SP)
9D00085C  AFA4001C   SW A0, 28(SP)
9D000860  AFA30018   SW V1, 24(SP)
9D000864  AFA20014   SW V0, 20(SP)
9D000868  AFA10010   SW AT, 16(SP)
9D00086C  00001012   MFLO V0, 0
9D000874  AFA2005C   SW V0, 92(SP)
9D000878  00001810   MFHI V1, 0
255:                    //_RA1 = ~_RA1;
256:                    Delayms(10);
9D000870  2404000A   ADDIU A0, ZERO, 10
9D00087C  0F400250   JAL Delayms
9D000880  AFA30058   SW V1, 88(SP)
257:                    SoftReset();
9D000884  0F400893   JAL SoftReset
9D000888  00000000   NOP
258:                    mINT0ClearIntFlag();
259:                 }
260:                 #endif
261:                 //#=================================================================================================
262:                 //#=================================================================================================
263:                 //#=================================================================================================
264:                 void  __attribute__((section("XCode"))) XCode( void )
265:                 {
266:                     NOP();
9D005000  00000000   NOP
267:                     NOP();
9D005004  00000000   NOP
268:                     NOP();
9D005008  00000000   NOP
269:                     NOP();
9D00500C  00000000   NOP
270:                     NOP();
9D005010  03E00008   JR RA
271:                 }
9D005014  00000000   NOP
272:                 //#=================================================================================================
273:                 
274:                 //#=================================================================================================
275:                 //#=================================================================================================
276:                 int __attribute__((section("XCodeMain"))) main( void ) {
9D000E88  27BDFFE0   ADDIU SP, SP, -32
9D000E94  AFB00014   SW S0, 20(SP)
9D000EA0  AFB10018   SW S1, 24(SP)
9D000F00  AFBF001C   SW RA, 28(SP)
277:                     int	pbClk;
278:                     //pbClk = SYSTEMConfig(SYS_FREQ>>4, SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
279:                     //pbClk = SYSTEMConfig(SYS_FREQ>>4, SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
280:                     //(DEBUG_JTAGPORT_OFF);
281:                 
282:                     ANSELA = 0x0;	//All pin digital
9D000E80  3C02BF88   LUI V0, -16504
9D000E84  AC406000   SW ZERO, 24576(V0)
283:                     ANSELB = 0x0;
9D000E8C  3C02BF88   LUI V0, -16504
9D000E90  AC406100   SW ZERO, 24832(V0)
284:                 
285:                     _TRISB13 = 1;
9D000E98  3C10BF88   LUI S0, -16504
9D000E9C  8E026110   LW V0, 24848(S0)
9D000EA4  24110001   ADDIU S1, ZERO, 1
9D000EA8  7E226B44   INS V0, S1, 13, 1
9D000EAC  AE026110   SW V0, 24848(S0)
286:                     U1RXRbits.U1RXR = 3; //SET RX to RPB13 > PIN 24
9D000EB0  3C02BF81   LUI V0, -16511
9D000EB4  8C43FA50   LW V1, -1456(V0)
9D000EB8  24040003   ADDIU A0, ZERO, 3
9D000EC0  7C831804   INS V1, A0, 0, 4
9D000EC4  AC43FA50   SW V1, -1456(V0)
287:                     RPB15Rbits.RPB15R = 1; //SET RPB15R to TX > PIN 26
9D000EC8  3C02BF81   LUI V0, -16511
9D000ECC  8C43FB68   LW V1, -1176(V0)
9D000ED8  7E231804   INS V1, S1, 0, 4
9D000EDC  AC43FB68   SW V1, -1176(V0)
288:                     U1BRG = (SYS_FREQ/17/(115200)); // calculate actual BAUD generate value.
9D000ED0  24040014   ADDIU A0, ZERO, 20
9D000EE0  3C02BF80   LUI V0, -16512
9D000EE4  AC446040   SW A0, 24640(V0)
289:                     //UARTSetDataRate(UART1, SYS_FREQ, 115200);
290:                     U1MODE = UART_EN;
9D000EE8  34038000   ORI V1, ZERO, -32768
9D000EEC  3C02BF80   LUI V0, -16512
9D000EF0  AC436000   SW V1, 24576(V0)
291:                     U1STA = (UART_RX_ENABLE | UART_TX_ENABLE);
9D000EBC  3C05BF80   LUI A1, -16512
9D000EF4  24021400   ADDIU V0, ZERO, 5120
9D000EF8  ACA26010   SW V0, 24592(A1)
292:                 
293:                     _TRISB5 = 1;
9D000EFC  8E056110   LW A1, 24848(S0)
9D000F04  7E252944   INS A1, S1, 5, 1
9D000F08  AE056110   SW A1, 24848(S0)
294:                     U2RXRbits.U2RXR = 1; //SET RX to RPB5
9D000F0C  3C05BF81   LUI A1, -16511
9D000F10  8CA6FA58   LW A2, -1448(A1)
9D000F14  7E261804   INS A2, S1, 0, 4
9D000F18  ACA6FA58   SW A2, -1448(A1)
295:                     RPB10Rbits.RPB10R = 2; //SET RPB0R to TX
9D000ED4  24070002   ADDIU A3, ZERO, 2
9D000F1C  3C05BF81   LUI A1, -16511
9D000F20  8CA6FB54   LW A2, -1196(A1)
9D000F24  7CE61804   INS A2, A3, 0, 4
9D000F28  ACA6FB54   SW A2, -1196(A1)
296:                     U2BRG = (SYS_FREQ/17/(115200));
9D000F2C  3C05BF80   LUI A1, -16512
9D000F30  ACA46240   SW A0, 25152(A1)
297:                     //UARTSetDataRate(UART2, SYS_FREQ, 115200);
298:                     U2MODE = UART_EN;
9D000F34  3C04BF80   LUI A0, -16512
9D000F38  AC836200   SW V1, 25088(A0)
299:                     U2STA = (UART_RX_ENABLE | UART_TX_ENABLE);
9D000F3C  3C03BF80   LUI V1, -16512
9D000F40  0F4008DD   JAL INTEnableSystemMultiVectoredInt
300:                 
301:                     INTEnableSystemMultiVectoredInt();
9D000F44  AC626210   SW V0, 25104(V1)
302:                 
303:                     asm(" lui  $gp, 0xa000 ");
9D000F48  3C1CA000   LUI GP, -24576
304:                 
305:                     _TRISB7 =1;
9D000F4C  8E026110   LW V0, 24848(S0)
9D000F50  7E2239C4   INS V0, S1, 7, 1
9D000F54  AE026110   SW V0, 24848(S0)
306:                     //asm(" nop ");
307:                     //INT0_INIT();
308:                     //asm(" nop ");
309:                 
310:                     //asm(" lui  $s0, 0x9d00 ");
311:                     asm(" lui  $s3, 0x9d00 ");
9D000F58  3C139D00   LUI S3, -25344
312:                     asm(" lui  $s1, 0xbf80 ");
9D000F5C  3C11BF80   LUI S1, -16512
313:                     asm(" lui  $s2, 0xbf88 ");
9D000F60  0F401400   JAL 0x9D005000
314:                 
315:                 
316:                     XCode();
9D000F64  3C12BF88   LUI S2, -16504
317:                 
318:                 
319:                     return (EXIT_SUCCESS);
320:                 }
9D000F68  8FBF001C   LW RA, 28(SP)
9D000F6C  00001021   ADDU V0, ZERO, ZERO
9D000F70  8FB10018   LW S1, 24(SP)
9D000F74  8FB00014   LW S0, 20(SP)
9D000F78  03E00008   JR RA
9D000F7C  27BD0020   ADDIU SP, SP, 32
321:                 //#=================================================================================================
322:                 
323:                 
324:                 
325:                 //#=================================================================================================
326:                 void  __attribute__((section("X_MM_1"))) mTouch_Main( void )
327:                 {
9D003C00  27BDFFD8   ADDIU SP, SP, -40
9D003C08  AFBF0024   SW RA, 36(SP)
9D003C0C  AFB20020   SW S2, 32(SP)
9D003C10  AFB1001C   SW S1, 28(SP)
9D003C14  AFB00018   SW S0, 24(SP)
328:                 //enum ST8S Switch1St8, Switch2St8, Switch3St8;
329:                 UINT16 CurrentButtonStatus  = 0,
9D003C18  A7A00010   SH ZERO, 16(SP)
330:                        CurrentButtonAsserts = 0,
9D003C1C  A7A00012   SH ZERO, 18(SP)
331:                        SliderValue = 0;
332:                 
333:                     DebugPrint_Hex(0XA15);DebugPrint_Space();
9D003C04  24040A15   ADDIU A0, ZERO, 2581
9D003C20  0F4002A8   JAL DebugPrint_Hex
9D003C24  A7A00014   SH ZERO, 20(SP)
9D003C28  0F4002B4   JAL DebugPrint_Space
9D003C2C  00000000   NOP
334:                     DebugPrint_CR();
9D003C30  0F4002B2   JAL DebugPrint_CR
9D003C34  00000000   NOP
335:                 
336:                     // Setup data structures for using Direct Keys
337:                     mTouchCapApp_DirectKeys_Create();
9D003C38  0F4007DB   JAL mTouchCapApp_DirectKeys_Create
9D003C3C  00000000   NOP
338:                     mTouchCapAPI_Init(); // Initialize mTouchCap before UART init
9D003C40  0F40053A   JAL mTouchCapAPI_Init
9D003C44  00000000   NOP
339:                 
340:                     _TRISB13 = 1;
9D003C48  3C02BF88   LUI V0, -16504
9D003C4C  8C436110   LW V1, 24848(V0)
9D003C50  24120001   ADDIU S2, ZERO, 1
9D003C58  7E436B44   INS V1, S2, 13, 1
9D003C5C  AC436110   SW V1, 24848(V0)
341:                     U1RXRbits.U1RXR = 3; //SET RX to RPB13 > PIN 24
9D003C54  24050003   ADDIU A1, ZERO, 3
9D003C60  3C03BF81   LUI V1, -16511
9D003C64  8C64FA50   LW A0, -1456(V1)
9D003C70  7CA41804   INS A0, A1, 0, 4
9D003C74  AC64FA50   SW A0, -1456(V1)
342:                     RPB15Rbits.RPB15R = 1; //SET RPB15R to TX > PIN 26
9D003C78  3C03BF81   LUI V1, -16511
9D003C7C  8C64FB68   LW A0, -1176(V1)
9D003C80  7E441804   INS A0, S2, 0, 4
9D003C84  AC64FB68   SW A0, -1176(V1)
343:                     U1BRG = (SYS_FREQ/17/(115200)); // calculate actual BAUD generate value.
9D003C88  24040014   ADDIU A0, ZERO, 20
9D003C8C  3C03BF80   LUI V1, -16512
9D003C90  AC646040   SW A0, 24640(V1)
344:                     //UARTSetDataRate(UART1, SYS_FREQ, 115200);
345:                     U1MODE = UART_EN;
9D003C94  34048000   ORI A0, ZERO, -32768
9D003C98  3C03BF80   LUI V1, -16512
9D003C9C  AC646000   SW A0, 24576(V1)
346:                     U1STA = (UART_RX_ENABLE | UART_TX_ENABLE);
9D003CA0  24041400   ADDIU A0, ZERO, 5120
9D003CA4  3C03BF80   LUI V1, -16512
9D003CA8  AC646010   SW A0, 24592(V1)
347:                 
348:                     _TRISB7 =1;
9D003CAC  8C436110   LW V1, 24848(V0)
9D003CB0  7E4339C4   INS V1, S2, 7, 1
9D003CB4  AC436110   SW V1, 24848(V0)
349:                     INT0_INIT();
9D003CB8  0F4002E7   JAL INT0_INIT
9D003CBC  00000000   NOP
350:                 
351:                     
352:                     // Start button measurements
353:                     Set_ScanTimer_IE_Bit_State(ENABLE);  //Enable interrupt
9D003C68  3C11BF88   LUI S1, -16504
9D003CC0  8E221060   LW V0, 4192(S1)
9D003CC4  7E429CC4   INS V0, S2, 19, 1
9D003CC8  AE221060   SW V0, 4192(S1)
354:                     Set_ScanTimer_ON_Bit_State(ENABLE);  //Run timer
9D003C6C  3C10BF80   LUI S0, -16512
9D003CCC  8E020C00   LW V0, 3072(S0)
9D003CD0  7E427BC4   INS V0, S2, 15, 1
9D003CD4  AE020C00   SW V0, 3072(S0)
355:                 
356:                 
357:                     while(1)
358:                     {
359:                         if( mTouchCapStatus_Check( &CurrentButtonStatus, &CurrentButtonAsserts, &SliderValue ) )
9D003CD8  27A40010   ADDIU A0, SP, 16
9D003CDC  27A50012   ADDIU A1, SP, 18
9D003CE0  0F400649   JAL mTouchCapStatus_Check
9D003CE4  27A60014   ADDIU A2, SP, 20
9D003CE8  1040FFFC   BEQ V0, ZERO, 0x9D003CDC
9D003CEC  27A40010   ADDIU A0, SP, 16
360:                         {
361:                             //  SliderValue
362:                             //  CurrentButtonStatus : (CurrentButtonStatus >> 0)&0x1,
363:                 
364:                 
365:                             DebugPrint_Hex(SliderValue);DebugPrint_Space();
9D003CF0  0F4002A8   JAL DebugPrint_Hex
9D003CF4  97A40014   LHU A0, 20(SP)
9D003CF8  0F4002B4   JAL DebugPrint_Space
9D003CFC  00000000   NOP
366:                             DebugPrint_Hex(CurrentButtonStatus);DebugPrint_Space();
9D003D00  0F4002A8   JAL DebugPrint_Hex
9D003D04  97A40010   LHU A0, 16(SP)
9D003D08  0F4002B4   JAL DebugPrint_Space
9D003D0C  00000000   NOP
367:                 
368:                             DebugPrint_CR();
9D003D10  0F4002B2   JAL DebugPrint_CR
9D003D14  00000000   NOP
369:                 
370:                             Delay10us(100);
9D003D18  0F400863   JAL Delay10us
9D003D1C  24040064   ADDIU A0, ZERO, 100
371:                             EmTouchDataReady = 0;                       //Clear flag
9D003D20  A3800010   SB ZERO, 16(GP)
372:                             Set_ScanTimer_IE_Bit_State(ENABLE);     //Enable interrupt
9D003D24  8E221060   LW V0, 4192(S1)
9D003D28  7E429CC4   INS V0, S2, 19, 1
9D003D2C  AE221060   SW V0, 4192(S1)
9D003D30  0B400F33   J 0x9D003CCC
9D003D34  00000000   NOP
373:                             Set_ScanTimer_ON_Bit_State(ENABLE);     //Run timer
374:                         }
375:                 
376:                     } //end while (1)
377:                     
378:                 }
379:                 
380:                 
381:                 //#=================================================================================================
382:                 //#=================================================================================================
383:                 void mTouchCapApp_PortSetup(void)
384:                 {
385:                 
386:                     TRISA = INIT_TRISA_VALUE;
9D0022C4  3C02BF88   LUI V0, -16504
9D0022C8  AC406010   SW ZERO, 24592(V0)
387:                     TRISB = INIT_TRISB_VALUE;
9D0022CC  3C02BF88   LUI V0, -16504
9D0022D0  AC406110   SW ZERO, 24848(V0)
388:                 //    TRISC = INIT_TRISC_VALUE;
389:                 
390:                     PORTA = INIT_PORTA_VALUE;
9D0022D4  3C02BF88   LUI V0, -16504
9D0022D8  AC406020   SW ZERO, 24608(V0)
391:                     PORTB = INIT_PORTB_VALUE;
9D0022DC  3C02BF88   LUI V0, -16504
9D0022E0  AC406120   SW ZERO, 24864(V0)
392:                 //    PORTC = INIT_PORTC_VALUE;
393:                 
394:                    //necessary for standalone execution - disable JTAG
395:                     DDPCONbits.JTAGEN = 0;
9D0022E4  3C02BF81   LUI V0, -16511
9D0022E8  8C43F200   LW V1, -3584(V0)
9D0022F0  7C0318C4   INS V1, ZERO, 3, 1
9D0022F4  AC43F200   SW V1, -3584(V0)
396:                 
397:                     CTMUCONbits.ON = 1;
9D0022EC  24040001   ADDIU A0, ZERO, 1
9D0022F8  3C02BF81   LUI V0, -16511
9D0022FC  8C43A200   LW V1, -24064(V0)
9D002300  7C837BC4   INS V1, A0, 15, 1
9D002304  AC43A200   SW V1, -24064(V0)
398:                     CTMUCONbits.IRNG = 0x3;
9D002308  8C43A200   LW V1, -24064(V0)
9D00230C  24040003   ADDIU A0, ZERO, 3
9D002310  7C830804   INS V1, A0, 0, 2
9D002314  AC43A200   SW V1, -24064(V0)
399:                 }
9D002318  03E00008   JR RA
9D00231C  00000000   NOP
400:                 //#=================================================================================================
401:                 
402:                 
403:                 
404:                 
405:                 
406:                 
407:                 
408:                 //#=================================================================================================
409:                 //#=================================================================================================
410:                 
411:                 
